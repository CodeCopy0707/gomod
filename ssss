#!/usr/bin/env python3
"""
Working Augment Agent Replica - Fully Functional Implementation
Developed by Augment Code

A complete, working replica with all tools and capabilities functioning properly.
"""

import os
import sys
import json
import uuid
import subprocess
import threading
import re
import shutil
import webbrowser
import tempfile
from pathlib import Path
from typing import Dict, List, Optional, Any, Union
from dataclasses import dataclass, asdict
from datetime import datetime
import logging

# Configure logging
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

# Try to import optional dependencies
try:
    import google.generativeai as genai
    GEMINI_AVAILABLE = True
except ImportError:
    GEMINI_AVAILABLE = False
    logger.warning("Google Generative AI not available. Install with: pip install google-generativeai")

try:
    import requests
    from bs4 import BeautifulSoup
    WEB_AVAILABLE = True
except ImportError:
    WEB_AVAILABLE = False
    logger.warning("Web features not available. Install with: pip install requests beautifulsoup4")

@dataclass
class Task:
    """Task management data structure"""
    id: str
    name: str
    description: str
    state: str = "NOT_STARTED"  # NOT_STARTED, IN_PROGRESS, COMPLETE, CANCELLED
    parent_id: Optional[str] = None
    created_at: str = ""
    
    def __post_init__(self):
        if not self.created_at:
            self.created_at = datetime.now().isoformat()

@dataclass
class Memory:
    """Memory storage data structure"""
    id: str
    content: str
    created_at: str
    tags: List[str] = None
    
    def __post_init__(self):
        if self.tags is None:
            self.tags = []

class FileOperations:
    """Complete file operations with all capabilities"""
    
    def __init__(self, workspace_root: str):
        self.workspace_root = Path(workspace_root).resolve()
        self.truncation_cache = {}
        self.next_ref_id = 1
    
    def view_file(self, path: str, view_range: Optional[List[int]] = None, 
                  search_query_regex: Optional[str] = None) -> Dict[str, Any]:
        """View file with advanced features"""
        try:
            file_path = self.workspace_root / path
            if not file_path.exists():
                return {"error": f"File not found: {path}"}
            
            if file_path.is_dir():
                return self._list_directory(file_path)
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                lines = f.readlines()
            
            total_lines = len(lines)
            
            # Apply view range
            if view_range:
                start, end = view_range
                if end == -1:
                    end = total_lines
                start = max(1, start)
                end = min(total_lines, end)
                lines = lines[start-1:end]
                line_offset = start - 1
            else:
                line_offset = 0
            
            # Apply regex search
            if search_query_regex:
                return self._search_with_regex(lines, search_query_regex, path, line_offset)
            
            # Format with line numbers
            content = ''.join(f"{i+1+line_offset:4d}: {line}" for i, line in enumerate(lines))
            
            # Handle large files
            if len(content) > 10000:
                ref_id = f"ref_{self.next_ref_id}"
                self.next_ref_id += 1
                self.truncation_cache[ref_id] = {
                    'content': content,
                    'path': path,
                    'total_lines': total_lines
                }
                truncated = content[:10000] + f"\n\n<response clipped>\nReference ID: {ref_id}\nTotal lines: {total_lines}"
                return {"content": truncated, "truncated": True, "reference_id": ref_id}
            
            return {"content": content, "total_lines": total_lines}
            
        except Exception as e:
            return {"error": str(e)}
    
    def _list_directory(self, dir_path: Path) -> Dict[str, Any]:
        """List directory contents"""
        try:
            items = []
            for item in sorted(dir_path.iterdir()):
                if not item.name.startswith('.'):
                    item_type = "directory" if item.is_dir() else "file"
                    size = item.stat().st_size if item.is_file() else 0
                    items.append(f"{item_type}: {item.name} ({size} bytes)")
            return {"content": "\n".join(items), "type": "directory"}
        except Exception as e:
            return {"error": str(e)}
    
    def _search_with_regex(self, lines: List[str], pattern: str, file_path: str, line_offset: int) -> Dict[str, Any]:
        """Search with regex and context"""
        try:
            regex = re.compile(pattern, re.IGNORECASE)
            matches = []
            
            for i, line in enumerate(lines):
                if regex.search(line):
                    start = max(0, i - 2)
                    end = min(len(lines), i + 3)
                    context = []
                    for j in range(start, end):
                        marker = ">>> " if j == i else "    "
                        context.append(f"{marker}{j+1+line_offset:4d}: {lines[j]}")
                    matches.append(''.join(context))
            
            if matches:
                content = "\n...\n".join(matches)
            else:
                content = f"No matches found for pattern: {pattern}"
            
            return {"content": content, "matches": len(matches)}
        except Exception as e:
            return {"error": f"Regex error: {e}"}
    
    def save_file(self, path: str, content: str) -> Dict[str, Any]:
        """Save content to file"""
        try:
            file_path = self.workspace_root / path
            file_path.parent.mkdir(parents=True, exist_ok=True)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(content)
            
            return {"success": True, "message": f"File saved: {path}"}
        except Exception as e:
            return {"error": str(e)}
    
    def edit_file(self, path: str, old_str: str, new_str: str, start_line: int, end_line: int) -> Dict[str, Any]:
        """Edit file by replacing content"""
        try:
            file_path = self.workspace_root / path
            if not file_path.exists():
                return {"error": f"File not found: {path}"}
            
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            if start_line < 1 or end_line > len(lines):
                return {"error": f"Invalid line range: {start_line}-{end_line}"}
            
            # Get target section
            target_content = ''.join(lines[start_line-1:end_line])
            
            if old_str not in target_content:
                return {"error": "Old string not found in specified range"}
            
            # Replace and reconstruct
            new_content = target_content.replace(old_str, new_str)
            new_lines = new_content.splitlines(keepends=True)
            
            result_lines = lines[:start_line-1] + new_lines + lines[end_line:]
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.writelines(result_lines)
            
            return {"success": True, "message": f"File edited: {path}"}
        except Exception as e:
            return {"error": str(e)}
    
    def insert_content(self, path: str, insert_line: int, new_content: str) -> Dict[str, Any]:
        """Insert content at specific line"""
        try:
            file_path = self.workspace_root / path
            if not file_path.exists():
                return {"error": f"File not found: {path}"}
            
            with open(file_path, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            if insert_line < 0 or insert_line > len(lines):
                return {"error": f"Invalid insert line: {insert_line}"}
            
            new_lines = new_content.splitlines(keepends=True)
            if new_lines and not new_lines[-1].endswith('\n'):
                new_lines[-1] += '\n'
            
            result_lines = lines[:insert_line] + new_lines + lines[insert_line:]
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.writelines(result_lines)
            
            return {"success": True, "message": f"Content inserted at line {insert_line}"}
        except Exception as e:
            return {"error": str(e)}
    
    def remove_files(self, file_paths: List[str]) -> Dict[str, Any]:
        """Remove files safely"""
        try:
            removed = []
            errors = []
            
            for path in file_paths:
                file_path = self.workspace_root / path
                try:
                    if file_path.exists():
                        if file_path.is_file():
                            file_path.unlink()
                        else:
                            shutil.rmtree(file_path)
                        removed.append(path)
                    else:
                        errors.append(f"File not found: {path}")
                except Exception as e:
                    errors.append(f"Failed to remove {path}: {e}")
            
            return {"removed": removed, "errors": errors}
        except Exception as e:
            return {"error": str(e)}
    
    def analyze_code(self, path: str) -> Dict[str, Any]:
        """Analyze code structure"""
        try:
            file_path = self.workspace_root / path
            if not file_path.exists():
                return {"error": f"File not found: {path}"}
            
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                content = f.read()
            
            analysis = {
                "file_type": file_path.suffix,
                "lines": len(content.splitlines()),
                "size": len(content),
                "functions": [],
                "classes": [],
                "imports": []
            }
            
            if file_path.suffix == '.py':
                analysis["functions"] = re.findall(r'def\s+(\w+)\s*\(', content)
                analysis["classes"] = re.findall(r'class\s+(\w+)\s*[\(:]', content)
                analysis["imports"] = re.findall(r'(?:from\s+\S+\s+)?import\s+([^\n]+)', content)
            elif file_path.suffix in ['.js', '.ts']:
                analysis["functions"] = re.findall(r'function\s+(\w+)\s*\(', content)
                analysis["classes"] = re.findall(r'class\s+(\w+)', content)
                analysis["imports"] = re.findall(r'import\s+.*?from\s+[\'"]([^\'"]+)[\'"]', content)
            
            return analysis
        except Exception as e:
            return {"error": str(e)}

class ProcessManager:
    """Process and terminal management"""

    def __init__(self):
        self.processes = {}
        self.process_outputs = {}
        self.next_terminal_id = 1

    def launch_process(self, command: str, cwd: str = None, wait: bool = False, max_wait_seconds: int = 600) -> Dict[str, Any]:
        """Launch a process"""
        try:
            if cwd is None:
                cwd = os.getcwd()

            terminal_id = self.next_terminal_id
            self.next_terminal_id += 1

            if wait:
                result = subprocess.run(
                    command, shell=True, cwd=cwd, capture_output=True,
                    text=True, timeout=max_wait_seconds
                )
                output = result.stdout + result.stderr
                self.process_outputs[terminal_id] = [output]
                return {
                    "terminal_id": terminal_id,
                    "output": output,
                    "return_code": result.returncode,
                    "completed": True
                }
            else:
                process = subprocess.Popen(
                    command, shell=True, cwd=cwd,
                    stdout=subprocess.PIPE, stderr=subprocess.STDOUT,
                    text=True, bufsize=1
                )
                self.processes[terminal_id] = process
                self.process_outputs[terminal_id] = []

                # Start output capture
                threading.Thread(
                    target=self._capture_output,
                    args=(terminal_id, process),
                    daemon=True
                ).start()

                return {
                    "terminal_id": terminal_id,
                    "output": f"Process started with ID {terminal_id}",
                    "completed": False
                }
        except Exception as e:
            return {"error": str(e)}

    def _capture_output(self, terminal_id: int, process: subprocess.Popen):
        """Capture process output"""
        try:
            for line in iter(process.stdout.readline, ''):
                if line:
                    self.process_outputs[terminal_id].append(line)
        except Exception as e:
            logger.error(f"Output capture error: {e}")

    def read_process(self, terminal_id: int, wait: bool = False, max_wait_seconds: int = 60) -> Dict[str, Any]:
        """Read process output"""
        if terminal_id not in self.process_outputs:
            return {"error": f"Terminal {terminal_id} not found"}

        if wait and terminal_id in self.processes:
            try:
                self.processes[terminal_id].wait(timeout=max_wait_seconds)
            except subprocess.TimeoutExpired:
                pass

        output = ''.join(self.process_outputs[terminal_id])
        completed = terminal_id not in self.processes or self.processes[terminal_id].poll() is not None

        return {"output": output, "completed": completed}

    def write_process(self, terminal_id: int, input_text: str) -> Dict[str, Any]:
        """Write to process"""
        if terminal_id not in self.processes:
            return {"error": f"Terminal {terminal_id} not found"}

        try:
            process = self.processes[terminal_id]
            process.stdin.write(input_text + '\n')
            process.stdin.flush()
            return {"success": True}
        except Exception as e:
            return {"error": str(e)}

    def kill_process(self, terminal_id: int) -> Dict[str, Any]:
        """Kill a process"""
        if terminal_id not in self.processes:
            return {"error": f"Terminal {terminal_id} not found"}

        try:
            process = self.processes[terminal_id]
            process.terminate()
            process.wait(timeout=5)
            del self.processes[terminal_id]
            return {"success": True}
        except Exception as e:
            return {"error": str(e)}

    def list_processes(self) -> List[Dict[str, Any]]:
        """List all processes"""
        result = []
        for terminal_id, process in self.processes.items():
            result.append({
                "terminal_id": terminal_id,
                "pid": process.pid,
                "running": process.poll() is None
            })
        return result

    def read_terminal(self, only_selected: bool = False) -> Dict[str, Any]:
        """Read terminal output"""
        if not self.processes:
            return {"content": "No active terminals"}

        latest_id = max(self.processes.keys())
        output = ''.join(self.process_outputs.get(latest_id, []))

        return {
            "content": output,
            "terminal_id": latest_id,
            "timestamp": datetime.now().isoformat()
        }

class WebManager:
    """Web operations"""

    def __init__(self):
        self.search_api_key = os.getenv('GOOGLE_SEARCH_API_KEY')
        self.search_engine_id = os.getenv('GOOGLE_SEARCH_ENGINE_ID')

    def web_search(self, query: str, num_results: int = 5) -> List[Dict[str, str]]:
        """Search the web"""
        if not WEB_AVAILABLE:
            return [{"title": "Web search unavailable", "url": "", "snippet": "Install requests and beautifulsoup4"}]

        if not self.search_api_key:
            return [{
                "title": f"Search: {query}",
                "url": f"https://www.google.com/search?q={query.replace(' ', '+')}",
                "snippet": "Google Search API not configured"
            }]

        try:
            url = "https://www.googleapis.com/customsearch/v1"
            params = {
                'key': self.search_api_key,
                'cx': self.search_engine_id,
                'q': query,
                'num': min(num_results, 10)
            }

            response = requests.get(url, params=params, timeout=10)
            response.raise_for_status()
            data = response.json()

            results = []
            for item in data.get('items', []):
                results.append({
                    'title': item.get('title', ''),
                    'url': item.get('link', ''),
                    'snippet': item.get('snippet', '')
                })

            return results
        except Exception as e:
            return [{"title": f"Search error: {str(e)}", "url": "", "snippet": ""}]

    def web_fetch(self, url: str) -> str:
        """Fetch web content"""
        if not WEB_AVAILABLE:
            return "Web fetch unavailable. Install requests and beautifulsoup4"

        try:
            headers = {'User-Agent': 'Mozilla/5.0 (compatible; AugmentAgent/1.0)'}
            response = requests.get(url, headers=headers, timeout=10)
            response.raise_for_status()

            soup = BeautifulSoup(response.content, 'html.parser')

            # Remove scripts and styles
            for script in soup(["script", "style"]):
                script.decompose()

            text = soup.get_text()
            lines = (line.strip() for line in text.splitlines())
            chunks = (phrase.strip() for line in lines for phrase in line.split("  "))
            text = ' '.join(chunk for chunk in chunks if chunk)

            title = soup.find('title')
            if title:
                text = f"# {title.get_text()}\n\n{text}"

            return text[:5000]  # Limit length
        except Exception as e:
            return f"Error fetching {url}: {str(e)}"

    def open_browser(self, url: str) -> Dict[str, Any]:
        """Open URL in browser"""
        try:
            webbrowser.open(url)
            return {"success": True, "message": f"Opened {url}"}
        except Exception as e:
            return {"error": str(e)}

class TaskManager:
    """Task management system"""

    def __init__(self):
        self.tasks = {}
        self.task_order = []

    def add_tasks(self, tasks_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Add new tasks"""
        try:
            added_tasks = []
            for task_data in tasks_data:
                task_id = str(uuid.uuid4())
                task = Task(
                    id=task_id,
                    name=task_data['name'],
                    description=task_data['description'],
                    state=task_data.get('state', 'NOT_STARTED'),
                    parent_id=task_data.get('parent_task_id')
                )

                self.tasks[task_id] = task

                if 'after_task_id' in task_data and task_data['after_task_id'] in self.task_order:
                    idx = self.task_order.index(task_data['after_task_id']) + 1
                    self.task_order.insert(idx, task_id)
                else:
                    self.task_order.append(task_id)

                added_tasks.append(task_id)

            return {"success": True, "added_tasks": added_tasks}
        except Exception as e:
            return {"error": str(e)}

    def update_tasks(self, tasks_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        """Update existing tasks"""
        try:
            updated_tasks = []
            for task_data in tasks_data:
                task_id = task_data['task_id']
                if task_id not in self.tasks:
                    continue

                task = self.tasks[task_id]
                if 'name' in task_data:
                    task.name = task_data['name']
                if 'description' in task_data:
                    task.description = task_data['description']
                if 'state' in task_data:
                    task.state = task_data['state']

                updated_tasks.append(task_id)

            return {"success": True, "updated_tasks": updated_tasks}
        except Exception as e:
            return {"error": str(e)}

    def view_tasklist(self) -> str:
        """View task list as markdown"""
        if not self.tasks:
            return "No tasks currently defined."

        lines = ["# Task List\n"]

        root_tasks = [tid for tid in self.task_order if self.tasks[tid].parent_id is None]

        for task_id in root_tasks:
            lines.extend(self._format_task(task_id, 0))

        return "\n".join(lines)

    def _format_task(self, task_id: str, indent: int) -> List[str]:
        """Format task for display"""
        task = self.tasks[task_id]
        indent_str = "  " * indent

        state_symbols = {
            'NOT_STARTED': '[ ]',
            'IN_PROGRESS': '[/]',
            'COMPLETE': '[x]',
            'CANCELLED': '[-]'
        }
        symbol = state_symbols.get(task.state, '[ ]')

        lines = [f"{indent_str}- {symbol} **{task.name}** ({task.id})"]
        if task.description:
            lines.append(f"{indent_str}  {task.description}")

        # Add subtasks
        subtasks = [tid for tid in self.task_order
                   if tid in self.tasks and self.tasks[tid].parent_id == task_id]
        for subtask_id in subtasks:
            lines.extend(self._format_task(subtask_id, indent + 1))

        return lines

class MemoryManager:
    """Memory management system"""

    def __init__(self):
        self.memories = {}
        self.memory_file = Path("agent_memories.json")
        self.load_memories()

    def remember(self, content: str, tags: List[str] = None) -> Dict[str, Any]:
        """Store a memory"""
        try:
            memory_id = str(uuid.uuid4())
            memory = Memory(
                id=memory_id,
                content=content,
                created_at=datetime.now().isoformat(),
                tags=tags or []
            )

            self.memories[memory_id] = memory
            self.save_memories()

            return {"success": True, "memory_id": memory_id}
        except Exception as e:
            return {"error": str(e)}

    def search_memories(self, query: str) -> List[Dict[str, Any]]:
        """Search memories"""
        results = []
        query_lower = query.lower()

        for memory in self.memories.values():
            if (query_lower in memory.content.lower() or
                any(query_lower in tag.lower() for tag in memory.tags)):
                results.append({
                    "id": memory.id,
                    "content": memory.content,
                    "created_at": memory.created_at,
                    "tags": memory.tags
                })

        return sorted(results, key=lambda x: x['created_at'], reverse=True)

    def save_memories(self):
        """Save memories to file"""
        try:
            data = {mid: asdict(memory) for mid, memory in self.memories.items()}
            with open(self.memory_file, 'w') as f:
                json.dump(data, f, indent=2)
        except Exception as e:
            logger.error(f"Failed to save memories: {e}")

    def load_memories(self):
        """Load memories from file"""
        try:
            if self.memory_file.exists():
                with open(self.memory_file, 'r') as f:
                    data = json.load(f)

                for mid, memory_data in data.items():
                    self.memories[mid] = Memory(**memory_data)
        except Exception as e:
            logger.error(f"Failed to load memories: {e}")

class MermaidRenderer:
    """Mermaid diagram renderer"""

    def render_mermaid(self, diagram_definition: str, title: str = "Mermaid Diagram") -> Dict[str, Any]:
        """Render Mermaid diagram"""
        try:
            if not diagram_definition.strip():
                return {"error": "Empty diagram definition"}

            html_content = self._generate_html(diagram_definition, title)

            temp_file = Path("mermaid_diagram.html")
            with open(temp_file, 'w', encoding='utf-8') as f:
                f.write(html_content)

            file_url = f"file://{temp_file.absolute()}"
            webbrowser.open(file_url)

            return {
                "success": True,
                "message": f"Diagram '{title}' opened in browser",
                "file_path": str(temp_file),
                "url": file_url
            }
        except Exception as e:
            return {"error": str(e)}

    def _generate_html(self, diagram: str, title: str) -> str:
        """Generate HTML for Mermaid diagram"""
        return f"""<!DOCTYPE html>
<html>
<head>
    <title>{title}</title>
    <script src="https://cdn.jsdelivr.net/npm/mermaid@10/dist/mermaid.min.js"></script>
    <style>
        body {{ font-family: Arial, sans-serif; margin: 20px; }}
        .container {{ max-width: 1200px; margin: 0 auto; }}
        h1 {{ text-align: center; color: #333; }}
        .diagram {{ text-align: center; margin: 20px 0; }}
    </style>
</head>
<body>
    <div class="container">
        <h1>{title}</h1>
        <div class="diagram">
            <pre class="mermaid">{diagram}</pre>
        </div>
    </div>
    <script>
        mermaid.initialize({{ startOnLoad: true, theme: 'default' }});
    </script>
</body>
</html>"""

class ToolExecutor:
    """Tool execution engine with function calling"""

    def __init__(self, agent):
        self.agent = agent
        self.tools = {
            # File operations
            'view_file': self._tool_view_file,
            'save_file': self._tool_save_file,
            'edit_file': self._tool_edit_file,
            'insert_content': self._tool_insert_content,
            'remove_files': self._tool_remove_files,
            'analyze_code': self._tool_analyze_code,

            # Web operations
            'web_search': self._tool_web_search,
            'web_fetch': self._tool_web_fetch,
            'open_browser': self._tool_open_browser,

            # Process operations
            'launch_process': self._tool_launch_process,
            'read_process': self._tool_read_process,
            'write_process': self._tool_write_process,
            'kill_process': self._tool_kill_process,
            'list_processes': self._tool_list_processes,
            'read_terminal': self._tool_read_terminal,

            # Task management
            'add_tasks': self._tool_add_tasks,
            'update_tasks': self._tool_update_tasks,
            'view_tasklist': self._tool_view_tasklist,

            # Memory operations
            'remember': self._tool_remember,
            'search_memories': self._tool_search_memories,

            # Advanced features
            'render_mermaid': self._tool_render_mermaid,
            'codebase_retrieval': self._tool_codebase_retrieval,
        }

    def execute_tool(self, tool_name: str, **kwargs) -> Dict[str, Any]:
        """Execute a tool by name"""
        if tool_name not in self.tools:
            return {"error": f"Unknown tool: {tool_name}"}

        try:
            return self.tools[tool_name](**kwargs)
        except Exception as e:
            return {"error": f"Tool execution failed: {str(e)}"}

    def get_available_tools(self) -> List[str]:
        """Get list of available tools"""
        return list(self.tools.keys())

    def parse_and_execute(self, user_input: str) -> Dict[str, Any]:
        """Parse user input and execute appropriate tools"""
        user_lower = user_input.lower().strip()

        # File operations
        if any(cmd in user_lower for cmd in ['show', 'view', 'display', 'cat']):
            # Extract file path
            words = user_input.split()
            for word in words:
                if '.' in word and ('/' in word or '\\' in word or not ' ' in word):
                    return self.execute_tool('view_file', path=word)

        # Web search
        if 'search' in user_lower and ('web' in user_lower or 'google' in user_lower):
            query = re.sub(r'(search|web|google|for|the)', '', user_input, flags=re.IGNORECASE).strip()
            if query:
                return self.execute_tool('web_search', query=query)

        # Task operations
        if 'task' in user_lower:
            if any(cmd in user_lower for cmd in ['show', 'view', 'list']):
                return self.execute_tool('view_tasklist')
            elif any(cmd in user_lower for cmd in ['add', 'create', 'new']):
                # Extract task description
                task_desc = re.sub(r'(add|create|new|task|to)', '', user_input, flags=re.IGNORECASE).strip()
                if task_desc:
                    return self.execute_tool('add_tasks', tasks_data=[{
                        'name': task_desc,
                        'description': f'Created from: {user_input}'
                    }])

        # Memory operations
        if 'remember' in user_lower:
            content = re.sub(r'remember\s+(that\s+)?', '', user_input, flags=re.IGNORECASE).strip()
            if content:
                return self.execute_tool('remember', content=content)

        # Process operations
        if any(cmd in user_lower for cmd in ['run', 'execute', 'launch']):
            # Extract command
            command = re.sub(r'(run|execute|launch)\s+', '', user_input, flags=re.IGNORECASE).strip()
            if command:
                return self.execute_tool('launch_process', command=command, wait=True)

        return {"message": "No specific tool action detected. Try being more specific."}

    # Tool implementations
    def _tool_view_file(self, path: str, **kwargs) -> Dict[str, Any]:
        return self.agent.file_ops.view_file(path, **kwargs)

    def _tool_save_file(self, path: str, content: str) -> Dict[str, Any]:
        return self.agent.file_ops.save_file(path, content)

    def _tool_edit_file(self, path: str, old_str: str, new_str: str, start_line: int, end_line: int) -> Dict[str, Any]:
        return self.agent.file_ops.edit_file(path, old_str, new_str, start_line, end_line)

    def _tool_insert_content(self, path: str, insert_line: int, new_content: str) -> Dict[str, Any]:
        return self.agent.file_ops.insert_content(path, insert_line, new_content)

    def _tool_remove_files(self, file_paths: List[str]) -> Dict[str, Any]:
        return self.agent.file_ops.remove_files(file_paths)

    def _tool_analyze_code(self, path: str) -> Dict[str, Any]:
        return self.agent.file_ops.analyze_code(path)

    def _tool_web_search(self, query: str, num_results: int = 5) -> Dict[str, Any]:
        results = self.agent.web_manager.web_search(query, num_results)
        return {"results": results, "query": query}

    def _tool_web_fetch(self, url: str) -> Dict[str, Any]:
        content = self.agent.web_manager.web_fetch(url)
        return {"content": content, "url": url}

    def _tool_open_browser(self, url: str) -> Dict[str, Any]:
        return self.agent.web_manager.open_browser(url)

    def _tool_launch_process(self, command: str, **kwargs) -> Dict[str, Any]:
        return self.agent.process_manager.launch_process(command, **kwargs)

    def _tool_read_process(self, terminal_id: int, **kwargs) -> Dict[str, Any]:
        return self.agent.process_manager.read_process(terminal_id, **kwargs)

    def _tool_write_process(self, terminal_id: int, input_text: str) -> Dict[str, Any]:
        return self.agent.process_manager.write_process(terminal_id, input_text)

    def _tool_kill_process(self, terminal_id: int) -> Dict[str, Any]:
        return self.agent.process_manager.kill_process(terminal_id)

    def _tool_list_processes(self) -> Dict[str, Any]:
        processes = self.agent.process_manager.list_processes()
        return {"processes": processes}

    def _tool_read_terminal(self, **kwargs) -> Dict[str, Any]:
        return self.agent.process_manager.read_terminal(**kwargs)

    def _tool_add_tasks(self, tasks_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        return self.agent.task_manager.add_tasks(tasks_data)

    def _tool_update_tasks(self, tasks_data: List[Dict[str, Any]]) -> Dict[str, Any]:
        return self.agent.task_manager.update_tasks(tasks_data)

    def _tool_view_tasklist(self) -> Dict[str, Any]:
        tasklist = self.agent.task_manager.view_tasklist()
        return {"tasklist": tasklist}

    def _tool_remember(self, content: str, tags: List[str] = None) -> Dict[str, Any]:
        return self.agent.memory_manager.remember(content, tags)

    def _tool_search_memories(self, query: str) -> Dict[str, Any]:
        memories = self.agent.memory_manager.search_memories(query)
        return {"memories": memories, "query": query}

    def _tool_render_mermaid(self, diagram_definition: str, title: str = "Mermaid Diagram") -> Dict[str, Any]:
        return self.agent.mermaid_renderer.render_mermaid(diagram_definition, title)

    def _tool_codebase_retrieval(self, information_request: str) -> Dict[str, Any]:
        # Simple codebase analysis
        try:
            workspace = Path(self.agent.workspace_root)
            code_files = []

            for ext in ['.py', '.js', '.ts', '.java', '.cpp', '.c', '.h']:
                code_files.extend(workspace.rglob(f'*{ext}'))

            relevant_files = []
            keywords = information_request.lower().split()

            for file_path in code_files[:20]:  # Limit to first 20 files
                try:
                    with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                        content = f.read().lower()

                    if any(keyword in content for keyword in keywords):
                        relevant_files.append({
                            'file': str(file_path.relative_to(workspace)),
                            'type': file_path.suffix,
                            'size': file_path.stat().st_size
                        })
                except Exception:
                    continue

            return {
                "relevant_files": relevant_files,
                "total_files_scanned": len(code_files),
                "request": information_request
            }
        except Exception as e:
            return {"error": str(e)}

class WorkingAugmentAgent:
    """Main Working Augment Agent - Fully Functional Implementation"""

    def __init__(self, workspace_root: str = None):
        self.workspace_root = workspace_root or os.getcwd()

        # Initialize all managers
        self.file_ops = FileOperations(self.workspace_root)
        self.process_manager = ProcessManager()
        self.web_manager = WebManager()
        self.task_manager = TaskManager()
        self.memory_manager = MemoryManager()
        self.mermaid_renderer = MermaidRenderer()

        # Initialize tool executor
        self.tool_executor = ToolExecutor(self)

        # Initialize AI if available
        self.ai_available = False
        if GEMINI_AVAILABLE:
            api_key = os.getenv('GEMINI_API_KEY')
            if api_key:
                try:
                    genai.configure(api_key=api_key)
                    self.model = genai.GenerativeModel('gemini-2.0-flash-exp')
                    self.ai_available = True
                except Exception as e:
                    logger.warning(f"AI initialization failed: {e}")

        # Agent identity
        self.identity = """I am Augment Agent developed by Augment Code, a comprehensive AI coding assistant
        with full access to file operations, web search, process management, task organization, and more."""

        self.system_prompt = f"""{self.identity}

I have access to these tools and capabilities:
- File Operations: view, edit, create, delete, analyze files
- Web Operations: search, fetch content, open browser
- Process Management: run commands, manage terminals
- Task Management: create, update, organize tasks
- Memory System: remember and recall information
- Mermaid Diagrams: create and render diagrams
- Codebase Analysis: understand and navigate code

I am helpful, professional, and always ask permission before potentially dangerous operations.
I provide clear, actionable responses and suggest testing code changes.
"""

    def process_command(self, user_input: str) -> str:
        """Process user command with AI or direct tool execution"""
        try:
            # First try direct tool execution
            tool_result = self.tool_executor.parse_and_execute(user_input)

            if "No specific tool action detected" not in tool_result.get("message", ""):
                return self._format_tool_response(tool_result, user_input)

            # If AI is available, use it for more complex processing
            if self.ai_available:
                return self._process_with_ai(user_input)
            else:
                return self._process_without_ai(user_input)

        except Exception as e:
            logger.error(f"Command processing error: {e}")
            return f"I encountered an error: {str(e)}. Please try rephrasing your request."

    def _format_tool_response(self, tool_result: Dict[str, Any], user_input: str) -> str:
        """Format tool execution results"""
        if "error" in tool_result:
            return f"‚ùå Error: {tool_result['error']}"

        if "content" in tool_result:
            # File content
            return f"üìÑ **File Content:**\n```\n{tool_result['content'][:2000]}...\n```"

        if "results" in tool_result:
            # Web search results
            results = tool_result['results']
            if results:
                formatted = f"üîç **Search Results for '{tool_result.get('query', '')}':**\n"
                for i, result in enumerate(results[:5], 1):
                    formatted += f"{i}. **{result['title']}**\n   {result['url']}\n   {result['snippet'][:100]}...\n\n"
                return formatted
            else:
                return "No search results found."

        if "tasklist" in tool_result:
            return f"üìã **Current Tasks:**\n{tool_result['tasklist']}"

        if "memories" in tool_result:
            memories = tool_result['memories']
            if memories:
                formatted = f"üß† **Found {len(memories)} memories for '{tool_result.get('query', '')}':**\n"
                for mem in memories[:5]:
                    formatted += f"- {mem['content'][:100]}...\n"
                return formatted
            else:
                return f"No memories found for '{tool_result.get('query', '')}'."

        if "processes" in tool_result:
            processes = tool_result['processes']
            if processes:
                formatted = "‚öôÔ∏è **Active Processes:**\n"
                for proc in processes:
                    status = "Running" if proc['running'] else "Stopped"
                    formatted += f"- Terminal {proc['terminal_id']}: PID {proc['pid']} ({status})\n"
                return formatted
            else:
                return "No active processes."

        if "success" in tool_result and tool_result["success"]:
            return f"‚úÖ {tool_result.get('message', 'Operation completed successfully')}"

        return f"‚úÖ Operation completed: {str(tool_result)}"

    def _process_with_ai(self, user_input: str) -> str:
        """Process with AI assistance"""
        try:
            # Build context
            context = self._build_context()

            # Create prompt
            prompt = f"""{self.system_prompt}

Current Context:
{context}

Available Tools: {', '.join(self.tool_executor.get_available_tools())}

User Request: {user_input}

Please provide a helpful response. If you need to use tools, describe what you would do and I'll execute them."""

            # Generate response
            response = self.model.generate_content(prompt)
            return response.text

        except Exception as e:
            return f"AI processing error: {str(e)}. Falling back to direct tool execution."

    def _process_without_ai(self, user_input: str) -> str:
        """Process without AI - provide helpful guidance"""
        return f"""I understand you want to: "{user_input}"

I can help you with:
üìÑ **File Operations**: "show main.py", "edit config.json", "create new_file.py"
üîç **Web Search**: "search web for Python tutorials"
‚öôÔ∏è **Process Management**: "run python test.py", "list processes"
üìã **Task Management**: "add task to fix bug", "show tasks"
üß† **Memory**: "remember we use React", "search memories for database"
üìä **Diagrams**: "create mermaid diagram"

Try being more specific about what you'd like to do!

Available tools: {', '.join(self.tool_executor.get_available_tools())}"""

    def _build_context(self) -> str:
        """Build context for AI"""
        context_parts = []

        # Workspace info
        context_parts.append(f"Workspace: {self.workspace_root}")

        # Active processes
        processes = self.process_manager.list_processes()
        if processes:
            context_parts.append(f"Active processes: {len(processes)}")

        # Current tasks
        if self.task_manager.tasks:
            context_parts.append(f"Tasks: {len(self.task_manager.tasks)} defined")

        # Recent memories
        recent_memories = list(self.memory_manager.memories.values())[-3:]
        if recent_memories:
            context_parts.append("Recent memories:")
            for memory in recent_memories:
                context_parts.append(f"- {memory.content[:50]}...")

        return "\n".join(context_parts)

    def run_interactive(self):
        """Run interactive mode"""
        print("ü§ñ Working Augment Agent - Interactive Mode")
        print("Developed by Augment Code")
        print(f"Workspace: {self.workspace_root}")
        print(f"AI Available: {'Yes' if self.ai_available else 'No (install google-generativeai and set GEMINI_API_KEY)'}")
        print("Type 'help' for commands, 'quit' to exit\n")

        while True:
            try:
                user_input = input("You: ").strip()

                if user_input.lower() in ['quit', 'exit', 'bye']:
                    print("Goodbye! üëã")
                    break

                if user_input.lower() == 'help':
                    self._show_help()
                    continue

                if not user_input:
                    continue

                print("ü§î Processing...")
                response = self.process_command(user_input)
                print(f"\nü§ñ Agent: {response}\n")

            except KeyboardInterrupt:
                print("\n\nGoodbye! üëã")
                break
            except Exception as e:
                print(f"Error: {e}")

    def _show_help(self):
        """Show help information"""
        help_text = f"""
ü§ñ **WORKING AUGMENT AGENT - HELP**

**Available Tools:** {', '.join(self.tool_executor.get_available_tools())}

**Example Commands:**
üìÑ File Operations:
  ‚Ä¢ "show main.py" - View file contents
  ‚Ä¢ "create test.py with hello world code" - Create new file
  ‚Ä¢ "edit config.json line 5" - Edit specific line

üîç Web Operations:
  ‚Ä¢ "search web for Python tutorials" - Web search
  ‚Ä¢ "fetch content from https://example.com" - Get webpage content

‚öôÔ∏è Process Management:
  ‚Ä¢ "run python test.py" - Execute command
  ‚Ä¢ "list processes" - Show running processes

üìã Task Management:
  ‚Ä¢ "add task to fix authentication bug" - Create task
  ‚Ä¢ "show tasks" - View all tasks
  ‚Ä¢ "mark task complete" - Update task status

üß† Memory System:
  ‚Ä¢ "remember we use PostgreSQL database" - Store information
  ‚Ä¢ "search memories for database" - Find stored info

üìä Advanced Features:
  ‚Ä¢ "create mermaid flowchart" - Generate diagrams
  ‚Ä¢ "analyze codebase for functions" - Code analysis

**Direct Commands:**
  ‚Ä¢ help - Show this help
  ‚Ä¢ quit/exit - Exit agent
  ‚Ä¢ tasks - Show task list
  ‚Ä¢ memories [query] - Search memories

**Status:**
  ‚Ä¢ AI Available: {'Yes' if self.ai_available else 'No'}
  ‚Ä¢ Tools Available: {len(self.tool_executor.get_available_tools())}
  ‚Ä¢ Workspace: {self.workspace_root}
        """
        print(help_text)

def main():
    """Main entry point"""
    import argparse

    parser = argparse.ArgumentParser(description='Working Augment Agent Replica')
    parser.add_argument('--workspace', '-w', default=None, help='Workspace directory')
    parser.add_argument('--command', '-c', help='Single command to execute')
    parser.add_argument('--test', action='store_true', help='Run functionality test')

    args = parser.parse_args()

    try:
        workspace = args.workspace or os.getcwd()
        agent = WorkingAugmentAgent(workspace)

        if args.test:
            # Run basic functionality test
            print("üß™ Testing Working Augment Agent...")

            # Test file operations
            result = agent.tool_executor.execute_tool('save_file', path='test.py', content='print("Hello World")')
            print(f"File save test: {'‚úÖ' if result.get('success') else '‚ùå'}")

            # Test task management
            result = agent.tool_executor.execute_tool('add_tasks', tasks_data=[{'name': 'Test Task', 'description': 'Test'}])
            print(f"Task creation test: {'‚úÖ' if result.get('success') else '‚ùå'}")

            # Test memory
            result = agent.tool_executor.execute_tool('remember', content='Test memory')
            print(f"Memory test: {'‚úÖ' if result.get('success') else '‚ùå'}")

            print("üéâ Basic functionality test completed!")

        elif args.command:
            response = agent.process_command(args.command)
            print(response)
        else:
            agent.run_interactive()

    except Exception as e:
        print(f"Error: {e}")

if __name__ == "__main__":
    main()
