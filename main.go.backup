package main

import (
	"bufio"
	"bytes"
	"context"
	"crypto/md5"
	"database/sql"
	"encoding/hex"
	"encoding/json"
	"fmt"
	"io"
	"io/ioutil"
	"log"
	"math"
	"net/http"
	"net/url"
	"os"
	"os/exec"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/fatih/color"
	"github.com/go-git/go-git/v5"
	"github.com/go-git/go-git/v5/plumbing"
	"github.com/go-git/go-git/v5/plumbing/object"
	"github.com/joho/godotenv"
	"github.com/manifoldco/promptui"
	"github.com/sahilm/fuzzy"
	"github.com/agnivade/levenshtein"
	_ "github.com/mattn/go-sqlite3"

	// AI model imports
	openai "github.com/sashabaranov/go-openai"
	"github.com/google/generative-ai-go/genai"
	geminioption "google.golang.org/api/option"
	mistral "github.com/mistralai/mistral-api-go/v3"
	mistralclient "github.com/mistralai/mistral-api-go/v3/client"
)

// -----------------------------------------------------------------------------
// 1. CONFIGURATION CONSTANTS & ADVANCED SETTINGS
// -----------------------------------------------------------------------------

const (
	// File handling limits
	maxFilesInAddDir         = 1000
	maxFileSizeInAddDir      = 5 * 1024 * 1024 // 5MB
	maxFileContentSizeCreate = 5 * 1024 * 1024 // 5MB
	maxMultipleReadSize      = 100 * 1024      // 100KB total limit for multiple file reads
	maxChunkSize             = 1000            // Lines per chunk for large file indexing

	// Fuzzy matching thresholds
	minFuzzyScore = 70 // Minimum score for file path fuzzy matching
	minEditScore  = 75 // Minimum score for code edit fuzzy matching

	// Command prefixes
	addCommandPrefix       = "/add "
	commitCommandPrefix    = "/commit "
	gitBranchCommandPrefix = "/git branch "
	helpCommandPrefix      = "/help"
	exitCommandPrefix      = "/exit"
	clearCommandPrefix     = "/clear"
	modelCommandPrefix     = "/model "
	configCommandPrefix    = "/config "

	// Context management
	maxHistoryMessages            = 50
	maxContextFiles               = 5
	estimatedMaxTokens            = 66000 // Conservative estimate for context window
	tokensPerMessageEstimate      = 200   // Average tokens per message
	tokensPerFileKB               = 300   // Estimated tokens per KB of file content
	contextWarningThreshold       = 0.8   // Warn when 80% of context is used
	aggressiveTruncationThreshold = 0.9   // More aggressive truncation at 90%

	// AI Models
	defaultModel  = "deepseek-chat"
	reasonerModel = "deepseek-reasoner"
	geminiModel   = "gemini-pro"
	mistralModel  = "mistral-large-latest"

	// API Keys environment variables
	mistralAPIKeyEnv  = "MISTRAL_API_KEY"
	geminiAPIKeyEnv   = "GEMINI_API_KEY"
	deepseekAPIKeyEnv = "DEEPSEEK_API_KEY"

	// Web search
	googleSearchAPIKeyEnv = "GOOGLE_SEARCH_API_KEY"
	googleSearchEngineEnv = "GOOGLE_SEARCH_ENGINE_ID"

	// Database
	databasePathEnv = "DATABASE_PATH"
	defaultDBPath   = "./agent_memory.db"

	// Performance settings
	maxConcurrentTasks    = 10
	defaultTimeout        = 30 * time.Second
	longOperationTimeout  = 5 * time.Minute
	prefetchWorkers       = 3
	cacheSize             = 1000
	cacheTTL              = 3600 // seconds

	// Terminal settings
	terminalTimeout     = 30 * time.Second
	commandHistorySize  = 100
	maxOutputLines      = 1000
	maxCommandLength    = 10000

	// Code analysis
	maxAnalysisDepth    = 10
	maxFunctionLines    = 100
	maxComplexityScore  = 15
	duplicateThreshold  = 0.8

	// Testing
	defaultTestTimeout = 5 * time.Minute
	maxTestFiles       = 50
	coverageThreshold  = 80.0

	// Security
	maxCommandLength    = 1000
	dangerousCommands   = "rm|del|format|fdisk|mkfs|dd|shutdown|reboot|halt|poweroff"
	sensitivePatterns   = "password|secret|key|token|credential"

	// Web interface (for future implementation)
	defaultWebPort = 8080
	defaultWebHost = "localhost"
)

var (
	excludedFiles = map[string]bool{
		// System files
		".DS_Store": true, "Thumbs.db": true, "desktop.ini": true, ".localized": true,

		// Version control
		".git": true, ".svn": true, ".hg": true, "CVS": true, ".gitignore": true, ".gitattributes": true,

		// Python
		".python-version": true, "uv.lock": true, ".uv": true, "uvenv": true, ".uvenv": true,
		".venv": true, "venv": true, "__pycache__": true, ".pytest_cache": true, ".coverage": true,
		".mypy_cache": true, ".tox": true, "pip-log.txt": true, "pip-delete-this-directory.txt": true,

		// Node.js
		"node_modules": true, "package-lock.json": true, "yarn.lock": true, "pnpm-lock.yaml": true,
		".next": true, ".nuxt": true, "dist": true, "build": true, ".cache": true, ".parcel-cache": true,
		".turbo": true, ".vercel": true, ".output": true, ".contentlayer": true, "out": true, "coverage": true,
		".nyc_output": true, "storybook-static": true, ".eslintcache": true,

		// Environment files
		".env": true, ".env.local": true, ".env.development": true, ".env.production": true,
		".env.staging": true, ".env.test": true,

		// IDE and editor files
		".idea": true, ".vscode": true, "*.swp": true, "*.swo": true, "*~": true, ".vim": true,

		// Build artifacts
		"target": true, "bin": true, "obj": true, "Debug": true, "Release": true, ".gradle": true,
		"build.gradle": true, "gradle-wrapper.properties": true, "gradlew": true, "gradlew.bat": true,

		// Logs and temporary files
		"logs": true, "*.log": true, "tmp": true, "temp": true, ".tmp": true, ".temp": true,

		// OS specific
		"$RECYCLE.BIN": true, "System Volume Information": true, ".Spotlight-V100": true,
		".Trashes": true, ".fseventsd": true, ".TemporaryItems": true,
	}

	excludedExtensions = map[string]bool{
		// Images
		".png": true, ".jpg": true, ".jpeg": true, ".gif": true, ".ico": true, ".svg": true,
		".webp": true, ".avif": true, ".bmp": true, ".tiff": true, ".tif": true, ".psd": true,
		".ai": true, ".eps": true, ".raw": true, ".cr2": true, ".nef": true, ".orf": true,

		// Videos
		".mp4": true, ".webm": true, ".mov": true, ".avi": true, ".mkv": true, ".flv": true,
		".wmv": true, ".m4v": true, ".3gp": true, ".ogv": true,

		// Audio
		".mp3": true, ".wav": true, ".ogg": true, ".flac": true, ".aac": true, ".wma": true,
		".m4a": true, ".opus": true,

		// Archives
		".zip": true, ".tar": true, ".gz": true, ".7z": true, ".rar": true, ".bz2": true,
		".xz": true, ".lzma": true, ".cab": true, ".deb": true, ".rpm": true, ".dmg": true,
		".iso": true, ".img": true,

		// Executables and binaries
		".exe": true, ".dll": true, ".so": true, ".dylib": true, ".bin": true, ".app": true,
		".msi": true, ".pkg": true, ".deb": true, ".rpm": true, ".apk": true, ".ipa": true,

		// Documents
		".pdf": true, ".doc": true, ".docx": true, ".xls": true, ".xlsx": true, ".ppt": true,
		".pptx": true, ".odt": true, ".ods": true, ".odp": true, ".rtf": true,

		// Compiled code
		".pyc": true, ".pyo": true, ".pyd": true, ".class": true, ".o": true, ".obj": true,
		".lib": true, ".a": true, ".jar": true, ".war": true, ".ear": true,

		// Package files
		".egg": true, ".whl": true, ".gem": true, ".nupkg": true,

		// Database files
		".db": true, ".sqlite": true, ".sqlite3": true, ".mdb": true, ".accdb": true,

		// Fonts
		".ttf": true, ".otf": true, ".woff": true, ".woff2": true, ".eot": true,

		// Minified/compiled web assets
		".min.js": true, ".min.css": true, ".bundle.js": true, ".bundle.css": true,
		".chunk.js": true, ".chunk.css": true, ".map": true,

		// Temporary and cache files
		".cache": true, ".tmp": true, ".temp": true, ".bak": true, ".backup": true,
		".old": true, ".orig": true, ".swp": true, ".swo": true,

		// System files
		".lnk": true, ".url": true, ".webloc": true,
	}

	// Supported programming languages for code analysis
	supportedLanguages = map[string]bool{
		".go": true, ".py": true, ".js": true, ".ts": true, ".jsx": true, ".tsx": true,
		".java": true, ".cpp": true, ".c": true, ".h": true, ".hpp": true, ".cc": true,
		".cxx": true, ".rs": true, ".dart": true, ".php": true, ".rb": true, ".kt": true,
		".swift": true, ".cs": true, ".scala": true, ".hs": true, ".lua": true, ".r": true,
		".m": true, ".sh": true, ".bash": true, ".zsh": true, ".fish": true, ".ps1": true,
		".sql": true, ".html": true, ".css": true, ".scss": true, ".sass": true, ".less": true,
		".vue": true, ".svelte": true, ".elm": true, ".clj": true, ".cljs": true, ".ex": true,
		".exs": true, ".erl": true, ".hrl": true, ".ml": true, ".mli": true, ".fs": true,
		".fsx": true, ".fsi": true, ".nim": true, ".cr": true, ".zig": true, ".v": true,
		".jl": true, ".pl": true, ".pm": true, ".t": true, ".tcl": true, ".tk": true,
		".vb": true, ".vbs": true, ".pas": true, ".pp": true, ".asm": true, ".s": true,
		".dockerfile": true, ".yaml": true, ".yml": true, ".json": true, ".xml": true,
		".toml": true, ".ini": true, ".cfg": true, ".conf": true, ".properties": true,
		".makefile": true, ".mk": true, ".cmake": true, ".gradle": true, ".sbt": true,
		".cabal": true, ".stack": true, ".cargo": true, ".mod": true, ".sum": true,
	}

	// Dangerous commands that require confirmation
	dangerousCommandPatterns = []string{
		`rm\s+-rf\s+/`,
		`rm\s+-rf\s+\*`,
		`del\s+/s\s+/q`,
		`format\s+`,
		`fdisk\s+`,
		`mkfs\s+`,
		`dd\s+`,
		`shutdown\s+`,
		`reboot\s+`,
		`halt\s+`,
		`poweroff\s+`,
		`sudo\s+rm\s+-rf`,
		`chmod\s+777\s+/`,
		`chown\s+-R\s+`,
		`find\s+.*-delete`,
		`truncate\s+-s\s+0`,
	}

	// Sensitive patterns to detect in code
	sensitivePatterns = []string{
		`password\s*=\s*["'][^"']+["']`,
		`secret\s*=\s*["'][^"']+["']`,
		`key\s*=\s*["'][^"']+["']`,
		`token\s*=\s*["'][^"']+["']`,
		`credential\s*=\s*["'][^"']+["']`,
		`api_key\s*=\s*["'][^"']+["']`,
		`private_key\s*=\s*["'][^"']+["']`,
		`access_token\s*=\s*["'][^"']+["']`,
		`refresh_token\s*=\s*["'][^"']+["']`,
		`database_url\s*=\s*["'][^"']+["']`,
		`connection_string\s*=\s*["'][^"']+["']`,
	}
)

// -----------------------------------------------------------------------------
// 2. GLOBAL STATE MANAGEMENT & ADVANCED CONTEXT
// -----------------------------------------------------------------------------

var (
	baseDir string

	// Git context with enhanced features
	gitContext = struct {
		Enabled       bool
		SkipStaging   bool
		Branch        string
		AutoCommit    bool
		AutoPush      bool
		CommitPrefix  string
		Repository    *git.Repository
		WorkTree      *git.Worktree
		LastCommitHash string
	}{
		Enabled:       false,
		SkipStaging:   false,
		Branch:        "",
		AutoCommit:    false,
		AutoPush:      false,
		CommitPrefix:  "[AI-Agent]",
		Repository:    nil,
		WorkTree:      nil,
		LastCommitHash: "",
	}

	// Model context with multi-provider support
	modelContext = struct {
		CurrentModel     string
		IsReasoner       bool
		Provider         string
		Temperature      float32
		MaxTokens        int
		TopP             float32
		FrequencyPenalty float32
		PresencePenalty  float32
		ModelHistory     []string
		LastSwitchTime   time.Time
	}{
		CurrentModel:     defaultModel,
		IsReasoner:       false,
		Provider:         "deepseek",
		Temperature:      0.7,
		MaxTokens:        4096,
		TopP:             0.9,
		FrequencyPenalty: 0.0,
		PresencePenalty:  0.0,
		ModelHistory:     []string{},
		LastSwitchTime:   time.Now(),
	}

	// Enhanced security context
	securityContext = struct {
		RequirePowershellConfirmation bool
		RequireBashConfirmation       bool
		AllowDangerousCommands        bool
		ScanForSecrets               bool
		LogAllCommands               bool
		MaxCommandLength             int
		BlockedCommands              []string
		TrustedDirectories           []string
		LastSecurityScan             time.Time
	}{
		RequirePowershellConfirmation: true,
		RequireBashConfirmation:       true,
		AllowDangerousCommands:        false,
		ScanForSecrets:               true,
		LogAllCommands:               true,
		MaxCommandLength:             maxCommandLength,
		BlockedCommands:              []string{},
		TrustedDirectories:           []string{},
		LastSecurityScan:             time.Now(),
	}

	// Performance and caching context
	performanceContext = struct {
		EnableCaching        bool
		EnablePrefetching    bool
		MaxConcurrentTasks   int
		CacheHitRate         float64
		TotalOperations      int64
		SuccessfulOperations int64
		AverageResponseTime  time.Duration
		LastOptimization     time.Time
		MemoryUsage          int64
		CPUUsage             float64
	}{
		EnableCaching:        true,
		EnablePrefetching:    true,
		MaxConcurrentTasks:   maxConcurrentTasks,
		CacheHitRate:         0.0,
		TotalOperations:      0,
		SuccessfulOperations: 0,
		AverageResponseTime:  0,
		LastOptimization:     time.Now(),
		MemoryUsage:          0,
		CPUUsage:             0.0,
	}

	// Conversation and context management
	conversationHistory []map[string]interface{}
	contextFiles        []string
	recentFiles         []string
	workingDirectory    string
	projectContext      = struct {
		ProjectType     string
		MainLanguage    string
		Framework       string
		Dependencies    []string
		TestFramework   string
		BuildTool       string
		PackageManager  string
		LastAnalysis    time.Time
		FileCount       int
		LinesOfCode     int
		Complexity      float64
	}{
		ProjectType:     "unknown",
		MainLanguage:    "unknown",
		Framework:       "unknown",
		Dependencies:    []string{},
		TestFramework:   "unknown",
		BuildTool:       "unknown",
		PackageManager:  "unknown",
		LastAnalysis:    time.Now(),
		FileCount:       0,
		LinesOfCode:     0,
		Complexity:      0.0,
	}

	// API keys and configuration
	apiKeys = struct {
		Mistral           string
		Gemini            string
		DeepSeek          string
		GoogleSearchAPI   string
		GoogleSearchEngine string
	}{}

	// AI clients with enhanced management
	deepseekClient *openai.Client
	geminiClient   *genai.GenerativeModel
	mistralClient  mistralclient.Client

	// Database for persistent memory
	memoryDB *sql.DB

	// Task management
	taskBucket = struct {
		Tasks         []Task
		CurrentTask   int
		CompletedTasks int
		TotalTasks    int
		StartTime     time.Time
		EstimatedEnd  time.Time
		mu            sync.RWMutex
	}{
		Tasks:         []Task{},
		CurrentTask:   -1,
		CompletedTasks: 0,
		TotalTasks:    0,
		StartTime:     time.Now(),
		EstimatedEnd:  time.Now(),
	}

	// Cache for frequently accessed data
	cache = struct {
		Data        map[string]CacheEntry
		mu          sync.RWMutex
		MaxSize     int
		CurrentSize int
		TTL         time.Duration
	}{
		Data:        make(map[string]CacheEntry),
		MaxSize:     cacheSize,
		CurrentSize: 0,
		TTL:         cacheTTL * time.Second,
	}

	// Command history and terminal state
	commandHistory = struct {
		Commands    []CommandEntry
		CurrentIndex int
		MaxSize     int
		mu          sync.RWMutex
	}{
		Commands:    []CommandEntry{},
		CurrentIndex: -1,
		MaxSize:     commandHistorySize,
	}

	// Web search capabilities
	webSearchContext = struct {
		Enabled       bool
		APIKey        string
		EngineID      string
		LastSearch    time.Time
		SearchHistory []SearchEntry
		CachedResults map[string]SearchResult
		mu            sync.RWMutex
	}{
		Enabled:       false,
		APIKey:        "",
		EngineID:      "",
		LastSearch:    time.Now(),
		SearchHistory: []SearchEntry{},
		CachedResults: make(map[string]SearchResult),
	}
)

// -----------------------------------------------------------------------------
// 3. COMPREHENSIVE TYPE DEFINITIONS & STRUCTS
// -----------------------------------------------------------------------------

// File operation types
type FileToCreate struct {
	Path    string `json:"path"`
	Content string `json:"content"`
}

type FileToEdit struct {
	Path            string `json:"path"`
	OriginalSnippet string `json:"original_snippet"`
	NewSnippet      string `json:"new_snippet"`
}

type FileInfo struct {
	Path         string    `json:"path"`
	Size         int64     `json:"size"`
	ModTime      time.Time `json:"mod_time"`
	IsDir        bool      `json:"is_dir"`
	Language     string    `json:"language"`
	LineCount    int       `json:"line_count"`
	Complexity   float64   `json:"complexity"`
	Dependencies []string  `json:"dependencies"`
	Functions    []string  `json:"functions"`
	Classes      []string  `json:"classes"`
	Imports      []string  `json:"imports"`
}

// Task management types
type Task struct {
	ID          string    `json:"id"`
	Title       string    `json:"title"`
	Description string    `json:"description"`
	Status      string    `json:"status"` // pending, in_progress, completed, failed
	Priority    int       `json:"priority"`
	CreatedAt   time.Time `json:"created_at"`
	UpdatedAt   time.Time `json:"updated_at"`
	CompletedAt *time.Time `json:"completed_at,omitempty"`
	EstimatedTime time.Duration `json:"estimated_time"`
	ActualTime    time.Duration `json:"actual_time"`
	Dependencies  []string `json:"dependencies"`
	SubTasks      []string `json:"sub_tasks"`
	Tags          []string `json:"tags"`
	Progress      float64  `json:"progress"`
	Error         string   `json:"error,omitempty"`
}

// Cache management types
type CacheEntry struct {
	Data      interface{} `json:"data"`
	CreatedAt time.Time   `json:"created_at"`
	ExpiresAt time.Time   `json:"expires_at"`
	AccessCount int       `json:"access_count"`
	LastAccess  time.Time `json:"last_access"`
	Size        int64     `json:"size"`
}

// Command history types
type CommandEntry struct {
	Command     string        `json:"command"`
	Output      string        `json:"output"`
	Error       string        `json:"error,omitempty"`
	ExitCode    int           `json:"exit_code"`
	ExecutedAt  time.Time     `json:"executed_at"`
	Duration    time.Duration `json:"duration"`
	WorkingDir  string        `json:"working_dir"`
	Environment map[string]string `json:"environment,omitempty"`
}

// Web search types
type SearchEntry struct {
	Query       string    `json:"query"`
	Results     []SearchResult `json:"results"`
	ExecutedAt  time.Time `json:"executed_at"`
	Duration    time.Duration `json:"duration"`
	ResultCount int       `json:"result_count"`
}

type SearchResult struct {
	Title       string `json:"title"`
	URL         string `json:"url"`
	Snippet     string `json:"snippet"`
	Relevance   float64 `json:"relevance"`
	Source      string `json:"source"`
	CachedAt    time.Time `json:"cached_at"`
}

// Code analysis types
type CodeAnalysis struct {
	FilePath        string    `json:"file_path"`
	Language        string    `json:"language"`
	LineCount       int       `json:"line_count"`
	FunctionCount   int       `json:"function_count"`
	ClassCount      int       `json:"class_count"`
	Complexity      float64   `json:"complexity"`
	Maintainability float64   `json:"maintainability"`
	TestCoverage    float64   `json:"test_coverage"`
	Issues          []CodeIssue `json:"issues"`
	Suggestions     []string  `json:"suggestions"`
	Dependencies    []string  `json:"dependencies"`
	Imports         []string  `json:"imports"`
	Exports         []string  `json:"exports"`
	AnalyzedAt      time.Time `json:"analyzed_at"`
}

type CodeIssue struct {
	Type        string `json:"type"` // error, warning, info, suggestion
	Message     string `json:"message"`
	Line        int    `json:"line"`
	Column      int    `json:"column"`
	Severity    string `json:"severity"`
	Rule        string `json:"rule"`
	Fixable     bool   `json:"fixable"`
	Suggestion  string `json:"suggestion,omitempty"`
}

// Testing types
type TestResult struct {
	TestFile    string        `json:"test_file"`
	Framework   string        `json:"framework"`
	Passed      int           `json:"passed"`
	Failed      int           `json:"failed"`
	Skipped     int           `json:"skipped"`
	Total       int           `json:"total"`
	Duration    time.Duration `json:"duration"`
	Coverage    float64       `json:"coverage"`
	Failures    []TestFailure `json:"failures"`
	ExecutedAt  time.Time     `json:"executed_at"`
}

type TestFailure struct {
	TestName    string `json:"test_name"`
	Message     string `json:"message"`
	StackTrace  string `json:"stack_trace"`
	Line        int    `json:"line"`
	Expected    string `json:"expected,omitempty"`
	Actual      string `json:"actual,omitempty"`
}

// Performance monitoring types
type PerformanceMetrics struct {
	Timestamp       time.Time     `json:"timestamp"`
	CPUUsage        float64       `json:"cpu_usage"`
	MemoryUsage     int64         `json:"memory_usage"`
	DiskUsage       int64         `json:"disk_usage"`
	NetworkIO       int64         `json:"network_io"`
	ResponseTime    time.Duration `json:"response_time"`
	ThroughputRPS   float64       `json:"throughput_rps"`
	ErrorRate       float64       `json:"error_rate"`
	ActiveTasks     int           `json:"active_tasks"`
	QueuedTasks     int           `json:"queued_tasks"`
}

// Security types
type SecurityScan struct {
	ScanType    string          `json:"scan_type"` // code, dependencies, secrets
	FilePath    string          `json:"file_path"`
	Issues      []SecurityIssue `json:"issues"`
	Score       float64         `json:"score"`
	ScanTime    time.Duration   `json:"scan_time"`
	ScannedAt   time.Time       `json:"scanned_at"`
}

type SecurityIssue struct {
	Type        string `json:"type"` // vulnerability, secret, insecure_code
	Severity    string `json:"severity"` // critical, high, medium, low
	Message     string `json:"message"`
	Line        int    `json:"line"`
	Column      int    `json:"column"`
	CWE         string `json:"cwe,omitempty"`
	CVE         string `json:"cve,omitempty"`
	Confidence  float64 `json:"confidence"`
	Remediation string `json:"remediation"`
}

// Project analysis types
type ProjectAnalysis struct {
	ProjectPath     string            `json:"project_path"`
	ProjectType     string            `json:"project_type"`
	MainLanguage    string            `json:"main_language"`
	Languages       map[string]int    `json:"languages"`
	Framework       string            `json:"framework"`
	Dependencies    []Dependency      `json:"dependencies"`
	FileCount       int               `json:"file_count"`
	LinesOfCode     int               `json:"lines_of_code"`
	TestCoverage    float64           `json:"test_coverage"`
	Complexity      float64           `json:"complexity"`
	Maintainability float64           `json:"maintainability"`
	TechnicalDebt   float64           `json:"technical_debt"`
	SecurityScore   float64           `json:"security_score"`
	AnalyzedAt      time.Time         `json:"analyzed_at"`
}

type Dependency struct {
	Name        string `json:"name"`
	Version     string `json:"version"`
	Type        string `json:"type"` // direct, transitive
	License     string `json:"license"`
	Vulnerabilities []string `json:"vulnerabilities"`
	UpdateAvailable string `json:"update_available,omitempty"`
}

// AI conversation types
type ConversationContext struct {
	SessionID       string                 `json:"session_id"`
	Messages        []Message              `json:"messages"`
	CurrentModel    string                 `json:"current_model"`
	TokensUsed      int                    `json:"tokens_used"`
	MaxTokens       int                    `json:"max_tokens"`
	Temperature     float32                `json:"temperature"`
	TopP            float32                `json:"top_p"`
	ContextFiles    []string               `json:"context_files"`
	WorkingDir      string                 `json:"working_dir"`
	ProjectContext  map[string]interface{} `json:"project_context"`
	UserPreferences map[string]interface{} `json:"user_preferences"`
	StartTime       time.Time              `json:"start_time"`
	LastActivity    time.Time              `json:"last_activity"`
}

type Message struct {
	Role        string                 `json:"role"` // user, assistant, system
	Content     string                 `json:"content"`
	ToolCalls   []ToolCall             `json:"tool_calls,omitempty"`
	ToolResults []ToolResult           `json:"tool_results,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Timestamp   time.Time              `json:"timestamp"`
	TokenCount  int                    `json:"token_count"`
}

type ToolCall struct {
	ID       string                 `json:"id"`
	Type     string                 `json:"type"`
	Function FunctionCall           `json:"function"`
	Metadata map[string]interface{} `json:"metadata,omitempty"`
}

type FunctionCall struct {
	Name      string `json:"name"`
	Arguments string `json:"arguments"`
}

type ToolResult struct {
	ToolCallID string                 `json:"tool_call_id"`
	Content    string                 `json:"content"`
	IsError    bool                   `json:"is_error"`
	Metadata   map[string]interface{} `json:"metadata,omitempty"`
	Duration   time.Duration          `json:"duration"`
}

// Tool represents a function call definition for the LLM
type Tool struct {
	Type     string `json:"type"`
	Function struct {
		Name        string `json:"name"`
		Description string `json:"description"`
		Parameters  struct {
			Type       string `json:"type"`
			Properties map[string]struct {
				Type        string `json:"type"`
				Description string `json:"description"`
				Items       *struct {
					Type string `json:"type"`
				} `json:"items,omitempty"`
				Properties *map[string]struct {
					Type string `json:"type"`
				} `json:"properties,omitempty"`
				Required []string `json:"required,omitempty"`
			} `json:"properties"`
			Required []string `json:"required"`
		} `json:"parameters"`
	}
}

// Enhanced tool metadata for better organization
type ToolMetadata struct {
	Name        string   `json:"name"`
	Category    string   `json:"category"`
	Description string   `json:"description"`
	Usage       string   `json:"usage"`
	Examples    []string `json:"examples"`
	Tags        []string `json:"tags"`
	Complexity  int      `json:"complexity"` // 1-5 scale
	Async       bool     `json:"async"`
	Dangerous   bool     `json:"dangerous"`
	RequiresConfirmation bool `json:"requires_confirmation"`
}

// Tool categories for organization
const (
	CategoryFileSystem    = "filesystem"
	CategoryGit          = "git"
	CategoryTerminal     = "terminal"
	CategoryCodeAnalysis = "code_analysis"
	CategoryTesting      = "testing"
	CategoryWebSearch    = "web_search"
	CategoryAI           = "ai"
	CategorySecurity     = "security"
	CategoryPerformance  = "performance"
	CategoryProject      = "project"
	CategoryTask         = "task_management"
	CategoryDebug        = "debugging"
	CategoryRefactor     = "refactoring"
	CategoryDocumentation = "documentation"
	CategoryDeployment   = "deployment"
)

// ChatCompletionChunk represents a chunk from the streaming API response
type ChatCompletionChunk struct {
	ID      string `json:"id"`
	Object  string `json:"object"`
	Created int64  `json:"created"`
	Model   string `json:"model"`
	Choices []struct {
		Index int `json:"index"`
		Delta struct {
			Role      string `json:"role,omitempty"`
			Content   string `json:"content,omitempty"`
			ToolCalls []struct {
				Index    int    `json:"index"`
				ID       string `json:"id"`
				Type     string `json:"type"`
				Function struct {
					Name      string `json:"name"`
					Arguments string `json:"arguments"`
				} `json:"function"`
			} `json:"tool_calls,omitempty"`
		} `json:"delta"`
		FinishReason string `json:"finish_reason,omitempty"`
	} `json:"choices"`
	Usage struct {
		PromptTokens     int `json:"prompt_tokens"`
		CompletionTokens int `json:"completion_tokens"`
		TotalTokens      int `json:"total_tokens"`
	} `json:"usage,omitempty"`
}

// Enhanced API response types
type APIResponse struct {
	Success     bool                   `json:"success"`
	Data        interface{}            `json:"data,omitempty"`
	Error       string                 `json:"error,omitempty"`
	ErrorCode   string                 `json:"error_code,omitempty"`
	Metadata    map[string]interface{} `json:"metadata,omitempty"`
	Duration    time.Duration          `json:"duration"`
	TokensUsed  int                    `json:"tokens_used,omitempty"`
	Model       string                 `json:"model,omitempty"`
	Provider    string                 `json:"provider,omitempty"`
	RequestID   string                 `json:"request_id,omitempty"`
	Timestamp   time.Time              `json:"timestamp"`
}

// Streaming response handler
type StreamHandler struct {
	OnChunk    func(chunk ChatCompletionChunk) error
	OnComplete func(response APIResponse) error
	OnError    func(error) error
	Buffer     strings.Builder
	TokenCount int
	StartTime  time.Time
}

// Rate limiting and API management
type APILimits struct {
	RequestsPerMinute int           `json:"requests_per_minute"`
	TokensPerMinute   int           `json:"tokens_per_minute"`
	RequestsPerDay    int           `json:"requests_per_day"`
	TokensPerDay      int           `json:"tokens_per_day"`
	ConcurrentRequests int          `json:"concurrent_requests"`
	Cooldown          time.Duration `json:"cooldown"`
	LastReset         time.Time     `json:"last_reset"`
	CurrentRequests   int           `json:"current_requests"`
	CurrentTokens     int           `json:"current_tokens"`
}

// Multi-provider AI client interface
type AIProvider interface {
	Name() string
	Models() []string
	Chat(ctx context.Context, messages []Message, options ChatOptions) (*APIResponse, error)
	Stream(ctx context.Context, messages []Message, options ChatOptions, handler StreamHandler) error
	TokenCount(text string) int
	MaxTokens() int
	IsAvailable() bool
	GetLimits() APILimits
}

type ChatOptions struct {
	Model            string    `json:"model"`
	Temperature      float32   `json:"temperature"`
	MaxTokens        int       `json:"max_tokens"`
	TopP             float32   `json:"top_p"`
	FrequencyPenalty float32   `json:"frequency_penalty"`
	PresencePenalty  float32   `json:"presence_penalty"`
	Stop             []string  `json:"stop,omitempty"`
	Tools            []Tool    `json:"tools,omitempty"`
	ToolChoice       string    `json:"tool_choice,omitempty"`
	Stream           bool      `json:"stream"`
	Timeout          time.Duration `json:"timeout"`
}

// -----------------------------------------------------------------------------
// 4. COMPREHENSIVE SYSTEM PROMPT & ADVANCED AI AGENT DEFINITION
// -----------------------------------------------------------------------------

const systemPrompt = `You are an Advanced AI Coding Terminal Agent - a highly sophisticated, autonomous coding assistant with comprehensive capabilities that rival and exceed the best coding tools available. You are designed to be a complete replacement for manual coding, debugging, testing, and project management tasks.

## 🧠 CORE IDENTITY & CAPABILITIES

You are a production-ready AI agent with:
- **Natural Language Understanding**: Process complex, multi-step instructions in plain English or Hindi
- **Autonomous Execution**: Complete entire projects from conception to deployment without manual intervention
- **Context Awareness**: Maintain deep understanding of project state, file relationships, and user intent
- **Predictive Intelligence**: Anticipate user needs and prepare solutions in advance
- **Multi-Language Mastery**: Expert-level proficiency in 20+ programming languages
- **Real-time Learning**: Adapt and improve based on project patterns and user feedback

## 🛠️ COMPREHENSIVE TOOL ARSENAL (25+ Advanced Tools)

### File System & Code Management
- **Smart File Operations**: Create, read, edit, delete with intelligent conflict resolution
- **Advanced Code Search**: Regex-powered search across entire codebases with context awareness
- **Intelligent Code Editing**: Fuzzy matching for precise code modifications
- **Large File Indexing**: Handle massive files by breaking them into manageable chunks
- **Code Refactoring Engine**: Extract functions, remove duplication, modularize code
- **Cross-Language Translation**: Convert code between programming languages

### Terminal & Command Execution
- **Secure Command Execution**: Run shell commands with safety checks and confirmation
- **Command History Management**: Track and learn from command patterns
- **Environment Detection**: Automatically detect and configure development environments
- **Package Management**: Install, update, remove dependencies across all ecosystems

### AI-Powered Analysis & Debugging
- **Autonomous Debugging**: Detect, analyze, and fix bugs automatically
- **Performance Profiling**: Identify bottlenecks and suggest optimizations
- **Security Scanning**: Detect vulnerabilities and security issues
- **Code Quality Analysis**: Enforce best practices and coding standards
- **Test Generation & Execution**: Create comprehensive test suites and run them

### Project & Task Management
- **Auto Task Planning**: Break down complex requests into executable sub-tasks
- **Progress Tracking**: Monitor task completion with real-time updates
- **Project Analysis**: Understand project structure, dependencies, and architecture
- **Documentation Generation**: Create API docs, README files, and inline comments

### Web Integration & Research
- **Web Search**: Find solutions, documentation, and code examples online
- **Information Retrieval**: Extract and adapt external resources to your project
- **API Documentation Lookup**: Access and summarize official documentation

### Git & Version Control
- **Intelligent Git Operations**: Commit, branch, merge with meaningful messages
- **Conflict Resolution**: Automatically resolve merge conflicts when possible
- **Change Analysis**: Understand and explain code changes

## 🚀 ADVANCED WORKFLOW CAPABILITIES

### Chain-of-Thought Reasoning
1. **Analyze**: Deep understanding of user intent and project context
2. **Plan**: Create detailed execution roadmap with dependencies and milestones
3. **Execute**: Perform tasks with real-time progress tracking
4. **Validate**: Test and verify all changes work correctly
5. **Optimize**: Refactor and improve code quality
6. **Document**: Generate comprehensive documentation

### Predictive Prefetching
- Background analysis of likely next steps
- Pre-generation of test cases and documentation
- Intelligent caching of frequently used patterns
- Context-aware suggestions and autocompletion

### Multi-Threaded Execution
- Parallel processing of independent tasks
- Concurrent file operations and analysis
- Background prefetching while handling user requests
- Real-time performance monitoring

## 🎯 INTERACTION PRINCIPLES

### Natural Language Processing
- Understand complex, multi-part instructions
- Handle ambiguous requests with intelligent clarification
- Support both English and Hindi inputs
- Maintain conversation context across sessions

### Autonomous Operation
- Execute complete workflows without manual intervention
- Make intelligent decisions based on best practices
- Handle errors gracefully with automatic recovery
- Provide transparent feedback on all actions

### Context Awareness
- Remember project history and user preferences
- Understand file relationships and dependencies
- Maintain awareness of current working state
- Adapt behavior based on project type and patterns

### Safety & Security
- Validate all operations before execution
- Scan for security vulnerabilities and secrets
- Require confirmation for potentially dangerous operations
- Maintain audit logs of all actions

## 📊 PERFORMANCE & MONITORING

### Real-time Metrics
- Track response times and throughput
- Monitor resource usage and optimization opportunities
- Measure task completion rates and accuracy
- Analyze user satisfaction and feedback

### Continuous Improvement
- Learn from successful patterns and failures
- Optimize tool usage based on project types
- Adapt to user preferences and coding styles
- Update knowledge base with new information

## 🔧 TECHNICAL SPECIFICATIONS

### Supported Languages & Frameworks
Python, JavaScript, TypeScript, Go, Java, C++, Rust, Dart, PHP, Ruby, Kotlin, Swift, C#, Scala, Haskell, Lua, R, MATLAB, Shell scripts, SQL, HTML, CSS, and more.

### Integration Capabilities
- Docker & Kubernetes
- CI/CD pipelines (GitHub Actions, Jenkins, CircleCI)
- Cloud platforms (AWS, GCP, Azure)
- Database systems (SQL and NoSQL)
- Testing frameworks across all languages
- Package managers and build tools

### Performance Targets
- Sub-second response times for simple operations
- Parallel processing for complex multi-file operations
- Intelligent caching for 90%+ cache hit rates
- 99.9% uptime and reliability

## 🎪 EXAMPLE WORKFLOW

User: "Create a full-stack e-commerce app with React, Node.js, MongoDB, and Stripe payments"

Agent Response:
1. **Analyze**: Identify technologies, architecture patterns, and requirements
2. **Plan**: Create 15+ sub-tasks covering frontend, backend, database, payments, testing, deployment
3. **Execute**:
   - Generate project structure with proper folder organization
   - Create React frontend with modern hooks and state management
   - Build Express.js backend with RESTful APIs
   - Set up MongoDB schemas and connections
   - Integrate Stripe payment processing
   - Generate comprehensive test suites
   - Create Docker configuration
   - Set up CI/CD pipeline
4. **Validate**: Run all tests, verify API endpoints, check payment flow
5. **Optimize**: Refactor code, improve performance, add error handling
6. **Document**: Generate API documentation, README, deployment guide

Result: Complete, production-ready e-commerce application with 95%+ test coverage, deployed and running.

## 🌟 YOUR MISSION

Be the ultimate coding companion that transforms ideas into reality. Handle everything from simple file edits to complex multi-service applications. Always strive for:
- **Excellence**: Produce production-quality code with best practices
- **Efficiency**: Complete tasks quickly without sacrificing quality
- **Intelligence**: Make smart decisions and learn from every interaction
- **Transparency**: Explain your actions and reasoning clearly
- **Reliability**: Deliver consistent, dependable results every time

You are not just a tool - you are a coding partner that makes software development effortless, enjoyable, and extraordinarily productive.`

// Tool metadata for organization and help system
var toolMetadata = map[string]ToolMetadata{
	"read_file": {
		Name: "read_file", Category: CategoryFileSystem, Complexity: 1,
		Description: "Read content from a single file",
		Usage: "Use when you need to examine file contents",
		Examples: []string{`read_file("src/main.go")`, `read_file("package.json")`},
		Tags: []string{"file", "read", "basic"},
	},
	"create_file": {
		Name: "create_file", Category: CategoryFileSystem, Complexity: 2,
		Description: "Create a new file with specified content",
		Usage: "Use when creating new files or overwriting existing ones",
		Examples: []string{`create_file("app.py", "print('Hello World')")`, `create_file("README.md", "# Project Title")`},
		Tags: []string{"file", "create", "write"},
	},
	"edit_file": {
		Name: "edit_file", Category: CategoryFileSystem, Complexity: 3,
		Description: "Edit existing files using fuzzy matching for precise modifications",
		Usage: "Use when modifying specific parts of existing files",
		Examples: []string{`edit_file("main.go", "func main()", "func main() {\n\tfmt.Println(\"Updated\")}")`},
		Tags: []string{"file", "edit", "modify", "fuzzy"},
	},
	"code_finder": {
		Name: "code_finder", Category: CategoryCodeAnalysis, Complexity: 3,
		Description: "Smart search for functions, variables, and code blocks using keywords or regex",
		Usage: "Use when searching for specific code patterns or symbols",
		Examples: []string{`code_finder("main.go", "func.*main", true)`, `code_finder("app.js", "useState", false)`},
		Tags: []string{"search", "code", "regex", "analysis"},
	},
	"auto_task_planner": {
		Name: "auto_task_planner", Category: CategoryTask, Complexity: 5,
		Description: "Break down complex requests into manageable sub-tasks with execution planning",
		Usage: "Use for complex multi-step projects that need structured planning",
		Examples: []string{`auto_task_planner("Build REST API", ["Setup project", "Create models", "Add endpoints"])`},
		Tags: []string{"planning", "tasks", "project", "management"},
	},
}

// -----------------------------------------------------------------------------
// 5. TOOLS REFERENCE - COMPREHENSIVE TOOLS DEFINED IN tools.go
// -----------------------------------------------------------------------------

// Tools are now defined in tools.go for better organization
// This provides access to 25+ comprehensive coding tools including:
// - File System Operations (read, write, edit, delete, search)
// - Code Analysis & Search (smart search, grep++, indexing)
// - Git & Version Control (smart commits, branch management)
// - Terminal & Command Execution (secure command execution, dependency management)
// - AI-Powered Analysis (debugging, refactoring, profiling, security scanning)
// - Testing & Quality Assurance (test generation, execution, coverage analysis)
// - Web Search & Information Retrieval (documentation lookup, code examples)
// - Task Management & Project Planning (auto task planning, progress tracking)
// - Project Analysis & Documentation (comprehensive analysis, API docs)
// - Utility & Helper Tools (input fixing, code translation)

// The tools variable is defined in tools.go and imported here

// -----------------------------------------------------------------------------
// 6. CORE FUNCTIONALITY & HELPER FUNCTIONS
// -----------------------------------------------------------------------------



	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "edit_file",
				Description: "Edit a file by replacing a snippet (supports fuzzy matching)",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"file_path":        {Type: "string", Description: "Path to the file"},
						"original_snippet": {Type: "string", Description: "Snippet to replace (supports fuzzy matching)"},
						"new_snippet":      {Type: "string", Description: "Replacement snippet"},
					},
					Required: []string{"file_path", "original_snippet", "new_snippet"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "git_init",
				Description: "Initialize a new Git repository.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{}, Required: []string{},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "git_commit",
				Description: "Commit staged changes with a message.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"message": {Type: "string", Description: "Commit message"},
					},
					Required: []string{"message"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "git_create_branch",
				Description: "Create and switch to a new Git branch.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"branch_name": {Type: "string", Description: "Name of the new branch"},
					},
					Required: []string{"branch_name"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "git_status",
				Description: "Show current Git status.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{}, Required: []string{},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "git_add",
				Description: "Stage files for commit.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						}{Type: "string"}, Description: "Paths of files to stage"},
					},
					Required: []string{"file_paths"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "run_powershell",
				Description: "Run a PowerShell command with security confirmation.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"command": {Type: "string", Description: "The PowerShell command to execute"},
					},
					Required: []string{"command"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "code_finder",
				Description: "Smart search for functions, variables, blocks using keywords or regex within a file.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"file_path": {Type: "string", Description: "The path to the file to search in."},
						"pattern":   {Type: "string", Description: "The keyword or regex pattern to search for."},
						"is_regex":  {Type: "boolean", Description: "True if the pattern is a regex, false for keyword search."},
					},
					Required: []string{"file_path", "pattern", "is_regex"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "string_replacer",
				Description: "Mass-change code lines or strings based on user instructions within a file.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"file_path":   {Type: "string", Description: "The path to the file to modify."},
						"old_string":  {Type: "string", Description: "The string or regex to find."},
						"new_string":  {Type: "string", Description: "The string to replace with."},
						"is_regex":    {Type: "boolean", Description: "True if old_string is a regex, false for literal string."},
						"all_matches": {Type: "boolean", Description: "True to replace all occurrences, false for first only."},
					},
					Required: []string{"file_path", "old_string", "new_string", "is_regex", "all_matches"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "grep_plus_plus",
				Description: "Ultra-smart grep across files with filters and patterns.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						}{Type: "string"}, Description: "The directory to start searching from."},
						"pattern":     {Type: "string", Description: "The regex pattern to search for."},
						"file_filter": {Type: "string", Description: "Optional glob pattern to filter files (e.g., '*.go', '*.js')."},
						"recursive":   {Type: "boolean", Description: "True for recursive search, false for top-level only."},
					},
					Required: []string{"directory", "pattern", "file_filter", "recursive"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "long_file_indexer",
				Description: "Break up and index massive files for context-aware editing.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						}{Type: "string"}, Description: "The path to the large file to index."},
						"chunk_size": {Type: "integer", Description: "The desired size of each chunk in lines."},
					},
					Required: []string{"file_path", "chunk_size"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "input_fixer",
				Description: "Auto-fix malformed code pasted from weird sources or screenshots.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						}{Type: "string"}, Description: "The malformed code snippet to fix."},
						"language":       {Type: "string", Description: "The programming language of the code (e.g., 'go', 'python', 'javascript')."},
					},
					Required: []string{"malformed_code", "language"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "auto_task_planner",
				Description: "Splits big asks into sub-steps, plans them, executes like a champ. Adds tasks to a bucket.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						}{Type: "string"},
							Description: "An array of sub-tasks to be executed sequentially.",
						},
					},
					Required: []string{"main_task_description", "sub_tasks"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "task_manager",
				Description: "Manages tasks in the task bucket (view, mark completed).",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"action": {Type: "string", Description: "Action to perform: 'view' or 'set_completed'."},
						"task_index": {Type: "integer", Description: "Index of the task to mark as completed (for 'set_completed' action)."},
					},
					Required: []string{"action"},
				},
			},
		},
	},
	{
		Type: "function",
		Function: struct {
			Name        string `json:"name"`
			Description string `json:"description"`
			Parameters  struct {
				Type       string `json:"type"`
				Properties map[string]struct {
					Type        string `json:"type"`
					Description string `json:"description"`
					Items       *struct {
						Type string `json:"type"`
					} `json:"items,omitempty"`
					Properties *map[string]struct {
						Type string `json:"type"`
					} `json:"properties,omitempty"`
					Required []string `json:"required,omitempty"`
				} `json:"properties"`
				Required []string `json:"required"`
			}{
				Name: "code_debugger",
				Description: "Analyzes code for errors, suggests fixes, and helps debug issues.",
				Parameters: struct {
					Type       string `json:"type"`
					Properties map[string]struct {
						Type        string `json:"type"`
						Description string `json:"description"`
						Items       *struct {
							Type string `json:"type"`
						} `json:"items,omitempty"`
						Properties *map[string]struct {
							Type string `json:"type"`
						} `json:"properties,omitempty"`
						Required []string `json:"required,omitempty"`
					}{
						"file_path": {Type: "string", Description: "The path to the file to debug."},
						"error_message": {Type: "string", Description: "The error message or stack trace."},
						"language": {Type: "string", Description: "The programming language of the code."},
					},
					Required: []string{"file_path", "error_message", "language"},
				},
			},
		},
	},
	{
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "code_refactor",
                Description: "Refactors code by extracting functions, removing duplication, or modularizing.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "file_path": {Type: "string", Description: "The path to the file to refactor."},
                        "refactor_type": {Type: "string", Description: "Type of refactoring: 'extract_function', 'remove_duplication', 'modularize'."},
                        "details": {Type: "string", Description: "Specific details for the refactoring (e.g., 'extract lines 10-20 into new function `calculate_total`')."},
                    },
                    Required: []string{"file_path", "refactor_type", "details"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "web_search",
                Description: "Searches the web for information using a query.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "query": {Type: "string", Description: "The search query."},
                    },
                    Required: []string{"query"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "test_runner",
                Description: "Generates and executes tests for given code, analyzes results.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "file_path": {Type: "string", Description: "Path to the code file to test."},
                        "test_framework": {Type: "string", Description: "Testing framework to use (e.g., 'jest', 'pytest', 'go test')."},
                        "test_type": {Type: "string", Description: "Type of test: 'unit', 'integration', 'e2e'."},
                    },
                    Required: []string{"file_path", "test_framework", "test_type"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "code_translator",
                Description: "Translates code from one programming language to another.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "source_code": {Type: "string", Description: "The code to translate."},
                        "source_language": {Type: "string", Description: "The original language of the code."},
                        "target_language": {Type: "string", Description: "The language to translate the code to."},
                    },
                    Required: []string{"source_code", "source_language", "target_language"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "dependency_manager",
                Description: "Manages project dependencies (install, update, remove).",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "action": {Type: "string", Description: "Action to perform: 'install', 'update', 'remove'."},
                        "package_name": {Type: "string", Description: "Name of the package."},
                        "language": {Type: "string", Description: "Programming language/ecosystem (e.g., 'node', 'python', 'go')."},
                    },
                    Required: []string{"action", "package_name", "language"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "api_doc_generator",
                Description: "Generates API documentation (e.g., Swagger/OpenAPI).",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "api_spec_path": {Type: "string", Description: "Path to the API specification file."},
                        "output_format": {Type: "string", Description: "Output format (e.g., 'json', 'yaml', 'html')."},
                    },
                    Required: []string{"api_spec_path", "output_format"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "code_profiler",
                Description: "Analyzes code for performance bottlenecks.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "file_path": {Type: "string", Description: "Path to the code file to profile."},
                        "language": {Type: "string", Description: "Programming language of the code."},
                    },
                    Required: []string{"file_path", "language"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "security_scanner",
                Description: "Scans code and dependencies for security vulnerabilities.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "scan_path": {Type: "string", Description: "Path to the directory or file to scan."},
                        "scan_type": {Type: "string", Description: "Type of scan: 'code', 'dependencies'."},
                    },
                    Required: []string{"scan_path", "scan_type"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "docker_manager",
                Description: "Manages Docker operations (build, run, compose).",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "action": {Type: "string", Description: "Action to perform: 'build', 'run', 'compose_up', 'compose_down'."},
                        "path": {Type: "string", Description: "Path to Dockerfile or docker-compose.yml."},
                        "image_name": {Type: "string", Description: "Optional: Image name for build/run actions."},
                    },
                    Required: []string{"action", "path"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "cicd_setup",
                Description: "Sets up CI/CD pipelines for various platforms (e.g., GitHub Actions).",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "platform": {Type: "string", Description: "CI/CD platform (e.g., 'github_actions', 'jenkins')."},
                        "config_details": {Type: "string", Description: "Details for the CI/CD configuration (e.g., 'build_script: npm run build')."},
                    },
                    Required: []string{"platform", "config_details"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "database_manager",
                Description: "Manages database operations (schema generation, query optimization).",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "db_type": {Type: "string", Description: "Database type (e.g., 'postgresql', 'mongodb')."},
                        "action": {Type: "string", Description: "Action to perform: 'generate_schema', 'optimize_query', 'execute_query'."},
                        "details": {Type: "string", Description: "Details for the action (e.g., 'schema_definition: CREATE TABLE users (id INT PRIMARY KEY)')."},
                    },
                    Required: []string{"db_type", "action", "details"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "api_client_generator",
                Description: "Generates API client code from a specification.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "spec_path": {Type: "string", Description: "Path to OpenAPI/Swagger specification."},
                        "target_language": {Type: "string", Description: "Target language for the client (e.g., 'javascript', 'go')."},
                        "output_path": {Type: "string", Description: "Output directory for the generated client."},
                    },
                    Required: []string{"spec_path", "target_language", "output_path"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "project_scaffolder",
                Description: "Generates boilerplate project structure for various frameworks.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "project_type": {Type: "string", Description: "Type of project (e.g., 'react-app', 'go-api', 'node-express')."},
                        "project_name": {Type: "string", Description: "Name of the new project directory."},
                        "options": {Type: "string", Description: "Optional: JSON string of additional options (e.g., '{ \"typescript\": true, \"tailwind\": true }')."},
                    },
                    Required: []string{"project_type", "project_name"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "env_setup",
                Description: "Sets up development environment (installs runtimes, configures virtual environments).",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "runtime": {Type: "string", Description: "Runtime to set up (e.g., 'node', 'python', 'go')."},
                        "version": {Type: "string", Description: "Optional: Specific version of the runtime."},
                        "path": {Type: "string", Description: "Optional: Path to set up the environment."},
                    },
                    Required: []string{"runtime"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "code_review_simulator",
                Description: "Simulates a code review, providing feedback on quality, readability, and maintainability.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "file_path": {Type: "string", Description: "Path to the code file to review."},
                        "guidelines": {Type: "string", Description: "Optional: Specific coding guidelines to follow."},
                    },
                    Required: []string{"file_path"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "documentation_lookup",
                Description: "Fetches and summarizes documentation for libraries, frameworks, or APIs.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "query": {Type: "string", Description: "The documentation search query (e.g., 'React useEffect hook')."},
                    },
                    Required: []string{"query"},
                },
            },
        },
    },
    {
        Type: "function",
        Function: struct {
            Name        string `json:"name"`
            Description string `json:"description"`
            Parameters  struct {
                Type       string `json:"type"`
                Properties map[string]struct {
                    Type        string `json:"type"`
                    Description string `json:"description"`
                    Items       *struct {
                        Type string `json:"type"`
                    } `json:"items,omitempty"`
                    Properties *map[string]struct {
                        Type string `json:"type"`
                    } `json:"properties,omitempty"`
                    Required []string `json:"required,omitempty"`
                } `json:"properties"`
                Required []string `json:"required"`
            }{
                Name: "interactive_debugger",
                Description: "Integrates with debuggers for step-by-step debugging and variable inspection.",
                Parameters: struct {
                    Type       string `json:"type"`
                    Properties map[string]struct {
                        Type        string `json:"type"`
                        Description string `json:"description"`
                        Items       *struct {
                            Type string `json:"type"`
                        } `json:"items,omitempty"`
                        Properties *map[string]struct {
                            Type string `json:"type"`
                        } `json:"properties,omitempty"`
                        Required []string `json:"required,omitempty"`
                    }{
                        "file_path": {Type: "string", Description: "Path to the file to debug."},
                        "breakpoint_line": {Type: "integer", Description: "Line number to set a breakpoint."},
                        "action": {Type: "string", Description: "Action to perform: 'start', 'step_over', 'step_into', 'continue', 'get_variable'."},
                        "variable_name": {Type: "string", Description: "Optional: Name of the variable to inspect."},
                    },
                    Required: []string{"file_path", "action"},
                },
            },
        },
    },
}

func normalizePath(pathStr string) string {
	p := filepath.Clean(pathStr)
	if filepath.IsAbs(p) {
		return p
	}
	return filepath.Join(baseDir, p)
}

func readLocalFile(filePath string) (string, error) {
	fullPath := normalizePath(filePath)
	content, err := ioutil.ReadFile(fullPath)
	if err != nil {
		return "", fmt.Errorf("error reading file '%s': %w", fullPath, err)
	}
	return string(content), nil
}

func isBinaryFile(filePath string, peekSize int) bool {
	f, err := os.Open(filePath)
	if err != nil {
		return true // Assume binary if cannot open
	}
	defer f.Close()

	buffer := make([]byte, peekSize)
	n, err := f.Read(buffer)
	if err != nil && err != io.EOF {
		return true // Assume binary if read error
	}

	for i := 0; i < n; i++ {
		if buffer[i] == 0 {
			return true // Null byte found, likely binary
		}
	}
	return false
}

func addFileContextSmartly(filePath, content string) bool {
	marker := fmt.Sprintf("User added file '%s'", filePath)

	contentSizeKB := float64(len(content)) / 1024
	estimatedTokens := len(content) / 4

	// Check if the last assistant message has pending tool calls (simplified check)
	if len(conversationHistory) > 0 {
		lastMsg := conversationHistory[len(conversationHistory)-1]
		if role, ok := lastMsg["role"].(string); ok && role == "assistant" {
			if _, hasToolCalls := lastMsg["tool_calls"]; hasToolCalls {
				color.Yellow("Deferring file context addition for '%s' until tool responses complete", filepath.Base(filePath))
				return true // Return true but don't add yet
			}
		}
	}

	// Remove any existing context for this exact file to avoid duplicates
	newHistory := []map[string]interface{}{}
	for _, msg := range conversationHistory {
		if role, ok := msg["role"].(string); ok && role == "system" {
			if content, ok := msg["content"].(string); ok && strings.Contains(content, marker) {
				continue
			}
		}
		newHistory = append(newHistory, msg)
	}
	conversationHistory = newHistory

	// Add new file context at the appropriate position
	insertionPoint := len(conversationHistory)
	for i := len(conversationHistory) - 1; i >= 0; i-- {
		if role, ok := conversationHistory[i]["role"].(string); ok && role == "user" {
			insertionPoint = i
			break
		}
	}

	newContextMsg := map[string]interface{}{
		"role":    "system",
		"content": fmt.Sprintf("%s. Content:\n\n%s", marker, content),
	}
	conversationHistory = append(conversationHistory[:insertionPoint], append([]map[string]interface{}{newContextMsg}, conversationHistory[insertionPoint:]...)...)

	color.Green("Added file context: %s (%.1fKB, ~%d tokens)", filepath.Base(filePath), contentSizeKB, estimatedTokens)
	return true
}

func estimateTokenUsage(history []map[string]interface{}) (int, map[string]int) {
	tokenBreakdown := map[string]int{"system": 0, "user": 0, "assistant": 0, "tool": 0}
	totalTokens := 0

	for _, msg := range history {
		role, _ := msg["role"].(string)
		content, _ := msg["content"].(string)

		contentTokens := len(content) / 4 // Basic estimation

		if _, ok := msg["tool_calls"]; ok {
			contentTokens += len(fmt.Sprintf("%v", msg["tool_calls"])) / 4
		}
		if _, ok := msg["tool_call_id"]; ok {
			contentTokens += 10 // Small overhead for tool metadata
		}

		tokenBreakdown[role] += contentTokens
		totalTokens += contentTokens
	}
	return totalTokens, tokenBreakdown
}

func getContextUsageInfo() map[string]interface{} {
	totalTokens, breakdown := estimateTokenUsage(conversationHistory)
	fileContexts := 0
	for _, msg := range conversationHistory {
		if role, ok := msg["role"].(string); ok && role == "system" {
			if content, ok := msg["content"].(string); ok && strings.Contains(content, "User added file") {
				fileContexts++
			}
		}
	}

	tokenUsagePercent := float64(totalTokens) / float64(estimatedMaxTokens) * 100

	return map[string]interface{}{
		"total_messages":      len(conversationHistory),
		"estimated_tokens":    totalTokens,
		"token_usage_percent": tokenUsagePercent,
		"file_contexts":       fileContexts,
		"token_breakdown":     breakdown,
		"approaching_limit":   totalTokens > int(float64(estimatedMaxTokens)*contextWarningThreshold),
		"critical_limit":      totalTokens > int(float64(estimatedMaxTokens)*aggressiveTruncationThreshold),
	}
}

func smartTruncateHistory(history []map[string]interface{}) []map[string]interface{} {
	// This is a simplified version. A full implementation would require more complex logic
	// to preserve tool call sequences and prioritize important messages based on token count.
	// For now, it will primarily rely on `maxHistoryMessages` and a basic token check.

	contextInfo := getContextUsageInfo()
	currentTokens := contextInfo["estimated_tokens"].(int)

	if currentTokens < int(float64(estimatedMaxTokens)*contextWarningThreshold) && len(history) <= maxHistoryMessages {
		return history
	}

	targetTokens := int(float64(estimatedMaxTokens) * 0.7) // Moderate reduction

	color.Yellow("Context limit approaching. Truncating to ~%d tokens.", targetTokens)

	// Always keep the initial system prompt
	if len(history) == 0 {
		return history
	}
	essentialSystem := []map[string]interface{}{history[0]}
	otherMessages := history[1:]

	// Simple truncation: keep recent messages up to target token count
	keptMessages := []map[string]interface{}{}
	currentTokenCount := 0
	for i := len(otherMessages) - 1; i >= 0; i-- {
		msg := otherMessages[i]
		msgTokens := len(fmt.Sprintf("%v", msg)) / 4 // Rough estimate
		if currentTokenCount+msgTokens <= targetTokens {
			keptMessages = append([]map[string]interface{}{msg}, keptMessages...)
			currentTokenCount += msgTokens
		} else {
			break
		}
	}

	result := append(essentialSystem, keptMessages...)
	finalTokens, _ := estimateTokenUsage(result)
	color.Cyan("Context truncated: %d -> %d messages, ~%d -> ~%d tokens", len(history), len(result), currentTokens, finalTokens)

	return result
}

func getModelIndicator() string {
	if modelContext.IsReasoner {
		return color.YellowString("🧠")
	}
	return color.BlueString("💬")
}

func getPromptIndicator() string {
	indicators := []string{}
	indicators = append(indicators, getModelIndicator())

	if gitContext.Enabled && gitContext.Branch != "" {
		indicators = append(indicators, color.GreenString("🌳 %s", gitContext.Branch))
	}

	contextInfo := getContextUsageInfo()
	if contextInfo["critical_limit"].(bool) {
		indicators = append(indicators, color.RedString("🔴"))
	} else if contextInfo["approaching_limit"].(bool) {
		indicators = append(indicators, color.YellowString("🟡"))
	} else {
		indicators = append(indicators, color.BlueString("🔵"))
	}

	return strings.Join(indicators, " ")
}

// -----------------------------------------------------------------------------
// 6. FILE OPERATIONS
// -----------------------------------------------------------------------------

func createFile(path, content string) error {
	normalizedPath := normalizePath(path)
	dir := filepath.Dir(normalizedPath)
	if err := os.MkdirAll(dir, 0755); err != nil {
		return fmt.Errorf("error creating directories for '%s': %w", normalizedPath, err)
	}

	if err := ioutil.WriteFile(normalizedPath, []byte(content), 0644); err != nil {
		return fmt.Errorf("error writing file '%s': %w", normalizedPath, err)
	}
	color.Blue("✓ Created/updated file at '%s'", normalizedPath)

	if gitContext.Enabled && !gitContext.SkipStaging {
		stageFile(normalizedPath)
	}
	return nil
}

func createMultipleFiles(files []FileToCreate) (string, error) {
	created := []string{}
	errors := []string{}
	for _, f := range files {
		err := createFile(f.Path, f.Content)
		if err != nil {
			errors = append(errors, fmt.Sprintf("Error creating %s: %v", f.Path, err))
		} else {
			created = append(created, f.Path)
		}
	}
	resParts := []string{}
	if len(created) > 0 {
		resParts = append(resParts, fmt.Sprintf("Created/updated %d files: %s", len(created), strings.Join(created, ", ")))
	}
	if len(errors) > 0 {
		resParts = append(resParts, fmt.Sprintf("Errors: %s", strings.Join(errors, "; ")))
	}
	if len(resParts) == 0 {
		return "No files processed.", nil
	}
	return strings.Join(resParts, ". ") + "."
}

func applyFuzzyDiffEdit(path, originalSnippet, newSnippet string) error {
	normalizedPath := normalizePath(path)
	content, err := readLocalFile(normalizedPath)
	if err != nil {
		return fmt.Errorf("file not found for diff: '%s'", normalizedPath)
	}

	// 1. First, try for an exact match
	if strings.Count(content, originalSnippet) == 1 {
		updatedContent := strings.Replace(content, originalSnippet, newSnippet, 1)
		color.Blue("✓ Applied exact diff edit to '%s'", normalizedPath)
		return createFile(normalizedPath, updatedContent)
	}

	// 2. If exact match fails, use fuzzy matching
	color.Yellow("Exact snippet not found. Trying fuzzy matching...")

	lines := strings.Split(content, "\n")
	originalLines := strings.Split(originalSnippet, "\n")
	originalLineCount := len(originalLines)

	bestMatchStartLine := -1
	highestScore := -1

	// Sliding window to find the best matching snippet
	for i := 0; i <= len(lines)-originalLineCount; i++ {
		currentSnippetLines := lines[i : i+originalLineCount]
		currentSnippet := strings.Join(currentSnippetLines, "\n")

		// Calculate Levenshtein distance as a similarity score (lower distance is better)
		// Convert distance to a similarity score (higher is better) for comparison with minEditScore
		distance := levenshtein.Distance(originalSnippet, currentSnippet)
		maxLength := len(originalSnippet)
		if len(currentSnippet) > maxLength {
			maxLength = len(currentSnippet)
		}
		score := 100 - (distance * 100 / maxLength) // Convert distance to a 0-100 score

		if score > highestScore {
			highestScore = score
			bestMatchStartLine = i
		}
	}

	if highestScore < minEditScore || bestMatchStartLine == -1 {
		return fmt.Errorf("fuzzy matching failed for '%s'. Score %d below threshold %d", normalizedPath, highestScore, minEditScore)
	}

	// Reconstruct the file content with the fuzzy replacement
	var updatedLines []string
	updatedLines = append(updatedLines, lines[:bestMatchStartLine]...)
	updatedLines = append(updatedLines, strings.Split(newSnippet, "\n")...)
	updatedLines = append(updatedLines, lines[bestMatchStartLine+originalLineCount:]...)

	color.Blue("✓ Applied fuzzy diff edit to '%s' (score: %d)", normalizedPath, highestScore)
	return createFile(normalizedPath, strings.Join(updatedLines, "\n"))
}

func addDirectoryToConversation(directoryPath string) {
	color.Blue("🔍 Scanning directory '%s'...", directoryPath)
	skipped := []string{}
	added := []string{}
	totalProcessed := 0

	filepath.Walk(directoryPath, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			skipped = append(skipped, fmt.Sprintf("%s (error: %v)", path, err))
			return nil
		}
		if totalProcessed >= maxFilesInAddDir {
			return filepath.SkipDir // Stop walking if max files reached
		}

		relPath, _ := filepath.Rel(baseDir, path)
		if relPath == "." { // Skip current directory itself
			return nil
		}

		// Check for excluded directories
		for dir := range excludedFiles { // Using excludedFiles for dir names too
			if info.IsDir() && info.Name() == dir {
				return filepath.SkipDir
			}
		}
		if info.IsDir() && strings.HasPrefix(info.Name(), ".") {
			return filepath.SkipDir
		}

		if !info.IsDir() {
			if excludedFiles[info.Name()] || excludedExtensions[filepath.Ext(info.Name())] {
				skipped = append(skipped, info.Name())
				return nil
			}

			if isBinaryFile(path, 1024) {
				skipped = append(skipped, fmt.Sprintf("%s (binary)", info.Name()))
				return nil
			}

			content, err := readLocalFile(path)
			if err != nil {
				skipped = append(skipped, fmt.Sprintf("%s (error: %v)", info.Name(), err))
				return nil
			}

			if len(content) > maxFileSizeInAddDir {
				skipped = append(skipped, fmt.Sprintf("%s (too large)", info.Name()))
				return nil
			}

			if addFileContextSmartly(path, content) {
				added = append(added, info.Name())
			} else {
				skipped = append(skipped, fmt.Sprintf("%s (context limit)", info.Name()))
			}
			totalProcessed++
		}
		return nil
	})

	color.Blue("✓ Added folder '%s'.", directoryPath)
	if len(added) > 0 {
		color.Green("📁 Added: (%d of %d valid) %s%s", len(added), totalProcessed, strings.Join(added[:min(len(added), 5)], ", "), ellipsis(len(added), 5))
	}
	if len(skipped) > 0 {
		color.Yellow("⏭ Skipped: (%d) %s%s", len(skipped), strings.Join(skipped[:min(len(skipped), 3)], ", "), ellipsis(len(skipped), 3))
	}
	fmt.Println()
}

func ellipsis(total, limit int) string {
	if total > limit {
		return "..."
	}
	return ""
}

// -----------------------------------------------------------------------------
// 7. GIT OPERATIONS
// -----------------------------------------------------------------------------

func createGitignore() error {
	gitignorePath := filepath.Join(baseDir, ".gitignore")
	if _, err := os.Stat(gitignorePath); err == nil {
		color.Yellow("⚠ .gitignore exists, skipping.")
		return nil
	}

	patterns := []string{
		"# Go", "*.exe", "*.dll", "*.so", "*.dylib", "*.bin",
		"# Python", "__pycache__/", "*.pyc", "*.pyo", "*.pyd", ".Python",
		"env/", "venv/", ".venv", "ENV/", "*.egg-info/", "dist/", "build/",
		".pytest_cache/", ".mypy_cache/", ".coverage", "htmlcov/", "",
		"# Env", ".env", ".env*.local", "!.env.example", "",
		"# IDE", ".vscode/", ".idea/", "*.swp", "*.swo", ".DS_Store", "",
		"# Logs", "*.log", "logs/", "",
		"# Temp", "*.tmp", "*.temp", "*.bak", "*.cache", "Thumbs.db",
		"desktop.ini", "",
		"# Node", "node_modules/", "npm-debug.log*", "yarn-debug.log*",
		"pnpm-lock.yaml", "package-lock.json", "",
		"# Local", "*.session", "*.checkpoint",
	}

	color.Blue("📝 Creating .gitignore")
	prompt := promptui.Prompt{
		Label:     color.BlueString("🔵 Add custom patterns? (y/n, default n)"),
		IsConfirm: true,
	}
	result, err := prompt.Run()
	if err == nil && strings.ToLower(result) == "y" {
		color.Cyan("Enter patterns (empty line to finish):")
		patterns = append(patterns, "\n# Custom")
		for {
			patternPrompt := promptui.Prompt{
				Label: "  Pattern",
			}
			pattern, _ := patternPrompt.Run()
			if pattern == "" {
				break
			}
			patterns = append(patterns, pattern)
		}
	}

	err = ioutil.WriteFile(gitignorePath, []byte(strings.Join(patterns, "\n")+"\n"), 0644)
	if err != nil {
		return fmt.Errorf("error creating .gitignore: %w", err)
	}
	color.Green("✓ Created .gitignore (%d patterns)", len(patterns))
	if gitContext.Enabled {
		stageFile(gitignorePath)
	}
	return nil
}

func stageFile(filePath string) bool {
	if !gitContext.Enabled || gitContext.SkipStaging {
		return false
	}
	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		color.Yellow("⚠ Not a git repository: %v", err)
		return false
	}
	wt, err := repo.Worktree()
	if err != nil {
		color.Red("✗ Error getting worktree: %v", err)
		return false
	}

	relPath, err := filepath.Rel(baseDir, filePath)
	if err != nil {
		color.Yellow("⚠ File %s outside repo (%s), skipping staging", filePath, baseDir)
		return false
	}

	_, err = wt.Add(relPath)
	if err != nil {
		color.Yellow("⚠ Failed to stage %s: %v", relPath, err)
		return false
	}
	color.Green("✓ Staged %s", relPath)
	return true
}

func getGitStatusPorcelain() (bool, []string) {
	if !gitContext.Enabled {
		return false, nil
	}
	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		color.Red("Error opening Git repository: %v", err)
		gitContext.Enabled = false
		return false, nil
	}
	wt, err := repo.Worktree()
	if err != nil {
		color.Red("Error getting worktree: %v", err)
		return false, nil
	}
	status, err := wt.Status()
	if err != nil {
		color.Red("Error getting Git status: %v", err)
		return false, nil
	}

	if status.IsClean() {
		return false, nil
	}

	var changes []string
	for _, s := range status {
		changes = append(changes, fmt.Sprintf("%s%s %s", string(s.Staging), string(s.Worktree), s.File))
	}
	return true, changes
}

func userCommitChanges(message string) bool {
	if !gitContext.Enabled {
		color.Yellow("Git not enabled.")
		return false
	}
	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		color.Red("Error opening Git repository: %v", err)
		return false
	}
	wt, err := repo.Worktree()
	if err != nil {
		color.Red("Error getting worktree: %v", err)
		return false
	}

	// Add all changes
	_, err = wt.Add(".")
	if err != nil {
		color.Yellow("⚠ Failed to stage all: %v", err)
	}

	status, err := wt.Status()
	if err != nil {
		color.Red("Error getting status before commit: %m", err)
		return false
	}
	if status.IsClean() {
		color.Yellow("No changes staged for commit.")
		return false
	}

	commitHash, err := wt.Commit(message, &git.CommitOptions{
		Author: &object.Signature{
			Name:  "DeepSeek Engineer",
			Email: "deepseek-engineer@example.com",
			When:  time.Now(),
		},
	})
	if err != nil {
		color.Red("✗ Commit failed: %v", err)
		return false
	}

	commit, err := repo.CommitObject(commitHash)
	if err != nil {
		color.Red("Error getting commit object: %v", err)
		return false
	}

	color.Green("✓ Committed: \"%s\"", message)
	color.Cyan("Commit: %s %s", commit.Hash.String()[:7], commit.Message)
	return true
}

// -----------------------------------------------------------------------------
// 8. ENHANCED COMMAND HANDLERS
// -----------------------------------------------------------------------------

func findBestMatchingFile(userPath string) (string, error) {
	var bestMatch string
	var highestScore int = 0

	// Walk through all files in baseDir recursively
	err := filepath.Walk(baseDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil // Continue walking on error
		}
		if info.IsDir() {
			// Skip excluded directories and hidden directories
			for dir := range excludedFiles {
				if info.Name() == dir {
					return filepath.SkipDir
				}
			}
			if strings.HasPrefix(info.Name(), ".") { // Skip hidden directories
				return filepath.SkipDir
			}

			if !info.IsDir() {
				// Skip excluded files and binary files
				if excludedFiles[info.Name()] || excludedExtensions[filepath.Ext(info.Name())] || isBinaryFile(path, 1024) {
					return nil
				}

				// Compare user's filename with actual filenames using fuzzy matching
				fileName := filepath.Base(path)
				_, score := fuzzy.Match(strings.ToLower(userPath), strings.ToLower(fileName))

				if score > highestScore {
					highestScore = score
					bestMatch = path
				}
			}
			return nil
		})
	if err != nil {
		return "", fmt.Errorf("error walking directory: %w", err)
	}

	if highestScore >= minFuzzyScore {
		return bestMatch, nil
	}
	return "", fmt.Errorf("no good fuzzy match found for '%s'", userPath)
}

func tryHandleAddCommand(userInput string) bool {
	if strings.HasPrefix(strings.ToLower(userInput), addCommandPrefix) {
		pathToAdd := strings.TrimSpace(userInput[len(addCommandPrefix):])
		if pathToAdd == "" {
			color.Yellow("Usage: /add <path>")
			return true
		}

		var normalizedPath string
		info, err := os.Stat(normalizePath(pathToAdd)) // Check direct path first
		if err == nil {
			normalizedPath = normalizePath(pathToAdd)
		} else if os.IsNotExist(err) {
			color.Yellow("Path '%s' not found directly, attempting fuzzy search...", pathToAdd)
			fuzzyMatch, fuzzyErr := findBestMatchingFile(pathToAdd)
			if fuzzyErr == nil {
				color.Cyan("Did you mean '%s'? (y/n)", fuzzyMatch)
				prompt := promptui.Prompt{
					Label:     color.BlueString("🔵 Confirm fuzzy match"),
					IsConfirm: true,
				}
				result, promptErr := prompt.Run()
				if promptErr == nil && strings.ToLower(result) == "y" {
					normalizedPath = fuzzyMatch
					info, err = os.Stat(normalizedPath) // Re-stat the fuzzy matched path
					if err != nil {
						color.Red("✗ Error accessing fuzzy matched path '%s': %v", normalizedPath, err)
						return true
					}
				} else {
					color.Yellow("Add command cancelled.")
					return true
				}
			} else {
				color.Red("✗ Path does not exist: '%s'. %v", pathToAdd, fuzzyErr)
				return true
			}
		} else {
			color.Red("✗ Error checking path '%s': %v", pathToAdd, err)
			return true
		}

		if info.IsDir() {
			addDirectoryToConversation(normalizedPath)
		} else {
			content, err := readLocalFile(normalizedPath)
			if err != nil {
				color.Red("✗ Could not read file '%s': %v", normalizedPath, err)
				return true
			}
			if addFileContextSmartly(normalizedPath, content) {
				color.Blue("✓ Added file '%s' to conversation.\n", normalizedPath)
			} else {
				color.Yellow("⚠ File '%s' too large for context.\n", normalizedPath)
			}
		}
		return true
	}
	return false
}

func tryHandleCommitCommand(userInput string) bool {
	if strings.HasPrefix(strings.ToLower(userInput), commitCommandPrefix) {
		if !gitContext.Enabled {
			color.Yellow("Git not enabled. `/git init` first.")
			return true
		}
		message := strings.TrimSpace(userInput[len(commitCommandPrefix):])
		if message == "" {
			prompt := promptui.Prompt{
				Label: color.BlueString("🔵 Enter commit message"),
			}
			var err error
			message, err = prompt.Run()
			if err != nil || message == "" {
				color.Yellow("Commit aborted. Message empty.")
				return true
			}
		}
		userCommitChanges(message)
		return true
	}
	return false
}

func tryHandleGitCommand(userInput string) bool {
	cmd := strings.ToLower(strings.TrimSpace(userInput))
	if cmd == "/git init" {
		return initializeGitRepoCmd()
	} else if strings.HasPrefix(cmd, gitBranchCommandPrefix) {
		branchName := strings.TrimSpace(userInput[len(gitBranchCommandPrefix):])
		if branchName == "" {
			color.Yellow("Specify branch name: /git branch <name>")
			return true
		}
		return createGitBranchCmd(branchName)
	} else if cmd == "/git status" {
		return showGitStatusCmd()
	}
	return false
}

func tryHandleGitInfoCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/git-info" {
		color.Blue("I can use Git commands to interact with a Git repository. Here's what I can do for you:\n\n" +
			"1. **Initialize a Git repository**: Use `git_init` to create a new Git repository in the current directory.\n" +
			"2. **Stage files for commit**: Use `git_add` to stage specific files for the next commit.\n" +
			"3. **Commit changes**: Use `git_commit` to commit staged changes with a message.\n" +
			"4. **Create and switch to a new branch**: Use `git_create_branch` to create a new branch and switch to it.\n" +
			"5. **Check Git status**: Use `git_status` to see the current state of the repository (staged, unstaged, or untracked files).\n\n" +
			"Let me know what you'd like to do, and I can perform the necessary Git operations for you. For example:\n" +
			"- Do you want to initialize a new repository?\n" +
			"- Stage and commit changes?\n" +
			"- Create a new branch? \n\n" +
			"Just provide the details, and I'll handle the rest!")
		return true
	}
	return false
}

func tryHandleR1Command(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/r1" {
		prompt := promptui.Prompt{
			Label: color.BlueString("🔵 Enter your reasoning prompt"),
		}
		userPrompt, err := prompt.Run()
		if err != nil || userPrompt == "" {
			color.Yellow("No input provided. Aborting.")
			return true
		}
		
		// Temporarily set model to reasoner for this call
		originalModel := modelContext.CurrentModel
		originalIsReasoner := modelContext.IsReasoner
		modelContext.CurrentModel = reasonerModel
		modelContext.IsReasoner = true

		conversationHistory = append(conversationHistory, map[string]interface{}{"role": "user", "content": userPrompt})
		
		// Call LLM with the reasoning prompt
		modelName := "DeepSeek Reasoner" // Assuming DeepSeek for reasoner for now
		if deepseekClient == nil {
			color.Red("DeepSeek client not initialized. Cannot use /r1.")
			// Revert model context
			modelContext.CurrentModel = originalModel
			modelContext.IsReasoner = originalIsReasoner
			return true
		}

		color.Yellow("🤖 %s is thinking...", modelName)
		fullResponseContent, _, err := callLLM(conversationHistory, modelContext.CurrentModel)
		if err != nil {
			color.Red("Error calling DeepSeek Reasoner: %v", err)
			fullResponseContent = fmt.Sprintf("Error: %v", err)
		} else {
			color.Magenta("🤖 %s: %s", modelName, fullResponseContent)
		}
		
		// No tool calls expected for /r1, just direct response
		conversationHistory = append(conversationHistory, map[string]interface{}{"role": "assistant", "content": fullResponseContent})

		// Revert model context
		modelContext.CurrentModel = originalModel
		modelContext.IsReasoner = originalIsReasoner
		return true
	}
	return false
}

func tryHandleReasonerCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/reasoner" {
		if modelContext.CurrentModel == defaultModel {
			modelContext.CurrentModel = reasonerModel
			modelContext.IsReasoner = true
			color.Green("✓ Switched to %s model 🧠", reasonerModel)
			color.Cyan("All subsequent conversations will use the reasoner model.")
		} else {
			modelContext.CurrentModel = defaultModel
			modelContext.IsReasoner = false
			color.Green("✓ Switched to %s model 💬", defaultModel)
			color.Cyan("All subsequent conversations will use the chat model.")
		}
		return true
	}
	return false
}

func tryHandleClearCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/clear" {
		// This is a terminal clear, not a Go-specific function
		// For Windows: cmd /c cls, For Unix-like: clear
		cmd := "clear"
		if os.Getenv("OS") == "Windows_NT" {
			cmd = "cmd /c cls"
		}
		// Execute the command
		// This is a simple exec, not using subprocess.Run for output capture
		// as it's just for clearing the screen.
		fmt.Print("\033[H\033[2J") // ANSI escape codes for clearing screen
		return true
	}
	return false
}

func tryHandleClearContextCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/clear-context" {
		if len(conversationHistory) <= 1 {
			color.Yellow("Context already empty (only system prompt).")
			return true
		}

		contextInfo := getContextUsageInfo()
		fileContexts := contextInfo["file_contexts"].(int)
		totalMessages := contextInfo["total_messages"].(int) - 1 // Exclude system prompt

		color.Yellow("Current context: %d messages, %d file contexts", totalMessages, fileContexts)

		prompt := promptui.Prompt{
			Label:     color.BlueString("🔵 Clear conversation context? This cannot be undone (y/n)"),
			IsConfirm: true,
		}
		result, err := prompt.Run()
		if err == nil && strings.ToLower(result) == "y" {
			originalSystemPrompt := conversationHistory[0]
			conversationHistory = []map[string]interface{}{originalSystemPrompt}
			color.Green("✓ Conversation context cleared. Starting fresh!")
			color.Green("  All file contexts and conversation history removed.")
		} else {
			color.Yellow("Context clear cancelled.")
		}
		return true
	}
	return false
}

func tryHandleFolderCommand(userInput string) bool {
	if strings.HasPrefix(strings.ToLower(userInput), "/folder") {
		folderPath := strings.TrimSpace(userInput[len("/folder"):])
		if folderPath == "" {
			color.Yellow("Current base directory: '%s'", baseDir)
			color.Yellow("Usage: /folder <path> or /folder reset")
			return true
		}
		if strings.ToLower(folderPath) == "reset" {
			oldBase := baseDir
			var err error
			baseDir, err = os.Getwd()
			if err != nil {
				color.Red("Error resetting base directory: %v", err)
				return true
			}
			color.Green("✓ Base directory reset from '%s' to: '%s'", oldBase, baseDir)
			return true
		}
		newBase, err := filepath.Abs(folderPath)
		if err != nil {
			color.Red("✗ Error resolving path: %v", err)
			return true
		}
		info, err := os.Stat(newBase)
		if os.IsNotExist(err) || !info.IsDir() {
			color.Red("✗ Path does not exist or is not a directory: '%s'", folderPath)
			return true
		}
		// Check write permissions
		testFile := filepath.Join(newBase, ".eng-git-test")
		f, err := os.Create(testFile)
		if err != nil {
			color.Red("✗ No write permissions in directory: '%s' (%v)", newBase, err)
			return true
		}
		f.Close()
		os.Remove(testFile)

		oldBase := baseDir
		baseDir = newBase
		color.Green("✓ Base directory changed from '%s' to: '%s'", oldBase, baseDir)
		color.Green("  All relative paths will now be resolved against this directory.")
		return true
	}
	return false
}

func tryHandleExitCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/exit" || strings.ToLower(strings.TrimSpace(userInput)) == "/quit" {
		color.Blue("👋 Goodbye!")
		os.Exit(0)
		return true
	}
	return false
}

func tryHandleContextCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/context" {
		contextInfo := getContextUsageInfo()

		fmt.Println(color.BlueString("📊 Context Usage Statistics"))
		fmt.Println(color.CyanString("Metric\t\tValue\t\tStatus"))
		fmt.Println(color.CyanString("------\t\t-----\t\t------"))
		fmt.Printf("Total Messages\t%d\t\t📝\n", contextInfo["total_messages"])
		fmt.Printf("Estimated Tokens\t%d\t\t%.1f%% of %d\n", contextInfo["estimated_tokens"], contextInfo["token_usage_percent"], estimatedMaxTokens)
		fmt.Printf("File Contexts\t%d\t\tMax: %d\n", contextInfo["file_contexts"], maxContextFiles)

		statusColor := color.GreenString
		statusText := "🟢 Healthy - plenty of space"
		if contextInfo["critical_limit"].(bool) {
			statusColor = color.RedString
			statusText = "🔴 Critical - aggressive truncation active"
		} else if contextInfo["approaching_limit"].(bool) {
			statusColor = color.YellowString
			statusText = "🟡 Warning - approaching limits"
		}
		fmt.Printf("Context Health\t%s\t\t\n", statusColor(statusText))

		if breakdown, ok := contextInfo["token_breakdown"].(map[string]int); ok && len(breakdown) > 0 {
			fmt.Println(color.BlueString("\n📋 Token Breakdown by Role"))
			fmt.Println(color.CyanString("Role\tTokens\tPercentage"))
			fmt.Println(color.CyanString("----\t------\t----------"))
			totalTokens := float64(contextInfo["estimated_tokens"].(int))
			for role, tokens := range breakdown {
				if tokens > 0 {
					percentage := (float64(tokens) / totalTokens * 100)
					fmt.Printf("%s\t%d\t%.1f%%\n", strings.Title(role), tokens, percentage)
				}
			}
		}

		if contextInfo["approaching_limit"].(bool) {
			color.Yellow("\n💡 Recommendations to manage context:")
			color.Yellow("  • Use /clear-context to start fresh")
			color.Yellow("  • Remove large files from context")
			color.Yellow("  • Work with smaller file sections")
		}
		return true
	}
	return false
}

func tryHandleHelpCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/help" {
		fmt.Println(color.BlueString("📝 Available Commands"))
		fmt.Println(color.CyanString("Command\t\tDescription"))
		fmt.Println(color.CyanString("-------\t\t-----------"))

		fmt.Printf("/help\t\tShow this help\n")
		fmt.Printf("/r1\t\tCall DeepSeek Reasoner model for one-off reasoning tasks\n")
		fmt.Printf("/reasoner\tToggle between chat and reasoner models\n")
		fmt.Printf("/clear\t\tClear screen\n")
		fmt.Printf("/clear-context\tClear conversation context\n")
		fmt.Printf("/context\tShow context usage statistics\n")
		fmt.Printf("/exit, /quit\tExit application\n")
		fmt.Printf("/folder\t\tShow current base directory\n")
		fmt.Printf("/folder <path>\tSet base directory for file operations\n")
		fmt.Printf("/folder reset\tReset base directory to current working directory\n")
		fmt.Printf("%s<path>\tAdd file/dir to conversation context (supports fuzzy matching)\n", addCommandPrefix)
		fmt.Printf("/git init\tInitialize Git repository\n")
		fmt.Printf("/git status\tShow Git status\n")
		fmt.Printf("%s<name>\tCreate & switch to new branch\n", gitBranchCommandPrefix)
		fmt.Printf("%s[msg]\tStage all files & commit (prompts if no message)\n", commitCommandPrefix)
		fmt.Printf("/git-info\tShow detailed Git capabilities\n")
		fmt.Printf("/task\t\tShow pending tasks from auto_task_planner\n")


		currentModelName := "DeepSeek Reasoner 🧠"
		if !modelContext.IsReasoner {
			currentModelName = "DeepSeek Chat 💬"
		}
		color.Cyan("\nCurrent model: %s", currentModelName)
		color.Green("Fuzzy matching: ✓ Implemented")
		return true
	}
	return false
}

func initializeGitRepoCmd() bool {
	if _, err := git.PlainOpen(baseDir); err == nil {
		color.Yellow("Git repo already exists.")
		gitContext.Enabled = true
		return true
	}
	repo, err := git.PlainInit(baseDir, false)
	if err != nil {
		color.Red("✗ Failed to init Git: %v", err)
		return false
	}
	gitContext.Enabled = true

	headRef, err := repo.Head()
	if err == nil {
		gitContext.Branch = headRef.Name().Short()
	} else {
		// Default branch name if HEAD is detached or no commits yet
		gitContext.Branch = "main"
	}

	color.Green("✓ Initialized Git repo in %s/.git/ (branch: %s)", baseDir, gitContext.Branch)

	if _, err := os.Stat(filepath.Join(baseDir, ".gitignore")); os.IsNotExist(err) {
		prompt := promptui.Prompt{
			Label:     color.BlueString("🔵 No .gitignore. Create one? (y/n, default y)"),
			IsConfirm: true,
		}
		result, err := prompt.Run()
		if err == nil && strings.ToLower(result) == "y" {
			createGitignore()
		}
	} else if gitContext.Enabled {
		stageFile(filepath.Join(baseDir, ".gitignore"))
	}

	prompt := promptui.Prompt{
		Label:     color.BlueString("🔵 Initial commit? (y/n, default n)"),
		IsConfirm: true,
	}
	result, err := prompt.Run()
	if err == nil && strings.ToLower(result) == "y" {
		userCommitChanges("Initial commit")
	}
	return true
}

func createGitBranchCmd(branchName string) bool {
	if !gitContext.Enabled {
		color.Yellow("Git not enabled.")
		return true
	}
	if branchName == "" {
		color.Yellow("Branch name empty.")
		return true
	}

	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		color.Red("Error opening Git repository: %v", err)
		return false
	}
	wt, err := repo.Worktree()
	if err != nil {
		color.Red("Error getting worktree: %v", err)
		return false
	}

	// Check if branch exists
	_, err = repo.Reference(plumbing.NewBranchReferenceName(branchName), false)
	if err == nil {
		color.Yellow("Branch '%s' exists.", branchName)
		headRef, err := repo.Head()
		if err == nil && headRef.Name().Short() != branchName {
			prompt := promptui.Prompt{
				Label:     color.BlueString("🔵 Switch to '%s'? (y/n, default y)", branchName),
				IsConfirm: true,
			}
			result, err := prompt.Run()
			if err == nil && strings.ToLower(result) == "y" {
				err = wt.Checkout(&git.CheckoutOptions{
					Branch: plumbing.NewBranchReferenceName(branchName),
				})
				if err != nil {
					color.Red("✗ Failed to switch to branch '%s': %v", branchName, err)
					return false
				}
				gitContext.Branch = branchName
				color.Green("✓ Switched to branch '%s'", branchName)
			}
		}
		return true
	}

	// Create and checkout new branch
	err = wt.Checkout(&git.CheckoutOptions{
		Create: true,
		Branch: plumbing.NewBranchReferenceName(branchName),
	})
	if err != nil {
		return fmt.Sprintf("Failed to create & switch to branch '%s': %v", branchName, err)
	}
	gitContext.Branch = branchName
	color.Green("✓ Created & switched to new branch '%s'", branchName)
	return true
}

func showGitStatusCmd() bool {
	if !gitContext.Enabled {
		color.Yellow("Git not enabled.")
		return true
	}
	hasChanges, files := getGitStatusPorcelain()

	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		color.Red("Error opening Git repository: %v", err)
		return false
	}
	headRef, err := repo.Head()
	branchMsg := "Not on any branch?"
	if err == nil {
		branchMsg = fmt.Sprintf("On branch %s", headRef.Name().Short())
	}
	fmt.Println(color.BlueString("Git Status"))
	fmt.Println(color.CyanString(branchMsg))

	if !hasChanges {
		color.Green("Working tree clean.")
		return true
	}

	fmt.Println(color.CyanString("Sts\tFile Path\tDescription"))
	fmt.Println(color.CyanString("---\t---------\t-----------"))

	staged, unstaged, untracked := false, false, false
	sMap := map[string]string{
		" M": "Mod (unstaged)", "MM": "Mod (staged&un)",
		" A": "Add (unstaged)", "AM": "Add (staged&mod)",
		"AD": "Add (staged&del)", " D": "Del (unstaged)",
		"??": "Untracked", "M ": "Mod (staged)",
		"A ": "Add (staged)", "D ": "Del (staged)",
		"R ": "Ren (staged)", "C ": "Cop (staged)",
		"U ": "Unmerged",
	}

	for _, line := range files {
		if len(line) < 3 {
			continue
		}
		code := line[:2]
		filename := line[3:]
		desc := sMap[code]
		fmt.Printf("%s\t%s\t%s\n", code, filename, desc)

		if code == "??" {
			untracked = true
		} else if strings.HasPrefix(code, " ") {
			unstaged = true
		} else {
			staged = true
		}
	}

	if !staged && (unstaged || untracked) {
		color.Yellow("\nNo changes added to commit.")
	}
	if staged {
		color.Green("\nChanges to be committed.")
	}
	if unstaged {
		color.Yellow("Changes not staged for commit.")
	}
	if untracked {
		color.Cyan("Untracked files present.")
	}
	return true
}

// -----------------------------------------------------------------------------
// 9. LLM TOOL HANDLER FUNCTIONS (Go implementation)
// -----------------------------------------------------------------------------

func llmGitInit() string {
	if _, err := git.PlainOpen(baseDir); err == nil {
		gitContext.Enabled = true
		return "Git repository already exists."
	}
	repo, err := git.PlainInit(baseDir, false)
	if err != nil {
		return fmt.Sprintf("Failed to initialize Git repository: %v", err)
	}
	gitContext.Enabled = true

	headRef, err := repo.Head()
	if err == nil {
		gitContext.Branch = headRef.Name().Short()
	} else {
		gitContext.Branch = "main" // Default if no commits yet
	}

	// Create .gitignore if it doesn't exist
	if _, err := os.Stat(filepath.Join(baseDir, ".gitignore")); os.IsNotExist(err) {
		createGitignore() // This will also stage it if git is enabled
	} else if gitContext.Enabled {
		stageFile(filepath.Join(baseDir, ".gitignore"))
	}

	return fmt.Sprintf("Git repository initialized successfully in %s/.git/ (branch: %s).", baseDir, gitContext.Branch)
}

func llmGitAdd(filePaths []string) string {
	if !gitContext.Enabled {
		return "Git not initialized."
	}
	if len(filePaths) == 0 {
		return "No file paths to stage."
	}
	stagedOK := []string{}
	failedStage := []string{}
	for _, fp := range filePaths {
		normalizedPath := normalizePath(fp)
		if stageFile(normalizedPath) {
			stagedOK = append(stagedOK, filepath.Base(normalizedPath))
		} else {
			failedStage = append(failedStage, filepath.Base(normalizedPath))
		}
	}
	res := []string{}
	if len(stagedOK) > 0 {
		res = append(res, fmt.Sprintf("Staged: %s", strings.Join(stagedOK, ", ")))
	}
	if len(failedStage) > 0 {
		res = append(res, fmt.Sprintf("Failed to stage: %s", strings.Join(failedStage, ", ")))
	}
	if len(res) == 0 {
		return "No files staged. Check paths."
	}
	return strings.Join(res, ". ") + "."
}

func llmGitCommit(message string) string {
	if !gitContext.Enabled {
		return "Git not initialized."
	}
	if message == "" {
		return "Commit message empty."
	}
	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		return fmt.Sprintf("Error opening Git repository: %v", err)
	}
	wt, err := repo.Worktree()
	if err != nil {
		return fmt.Sprintf("Error getting worktree: %v", err)
	}

	status, err := wt.Status()
	if err != nil {
		return fmt.Sprintf("Error getting status before commit: %v", err)
	}
	if status.IsClean() {
		return "No changes staged. Use git_add first."
	}

	commitHash, err := wt.Commit(message, &git.CommitOptions{
		Author: &object.Signature{
			Name:  "DeepSeek Engineer",
			Email: "deepseek-engineer@example.com",
			When:  time.Now(),
		},
	})
	if err != nil {
		return fmt.Sprintf("Failed to commit: %v", err)
	}

	commit, err := repo.CommitObject(commitHash)
	if err != nil {
		return fmt.Sprintf("Error getting commit object: %v", err)
	}

	return fmt.Sprintf("Committed. Commit: %s %s", commit.Hash.String()[:7], commit.Message)
}

func llmGitCreateBranch(branchName string) string {
	if !gitContext.Enabled {
		return "Git not initialized."
	}
	bn := strings.TrimSpace(branchName)
	if bn == "" {
		return "Branch name empty."
	}

	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		return fmt.Sprintf("Error opening Git repository: %v", err)
	}
	wt, err := repo.Worktree()
	if err != nil {
		return fmt.Sprintf("Error getting worktree: %v", err)
	}

	// Check if branch exists
	_, err = repo.Reference(plumbing.NewBranchReferenceName(bn), false)
	if err == nil {
		headRef, err := repo.Head()
		if err == nil && headRef.Name().Short() == bn {
			return fmt.Sprintf("Already on branch '%s'.", bn)
		}
		err = wt.Checkout(&git.CheckoutOptions{
			Branch: plumbing.NewBranchReferenceName(bn),
		})
		if err != nil {
			return fmt.Sprintf("Failed to switch to branch '%s': %v", bn, err)
		}
		gitContext.Branch = bn
		return fmt.Sprintf("Branch '%s' exists. Switched to it.", bn)
	}

	// Create and checkout new branch
	err = wt.Checkout(&git.CheckoutOptions{
		Create: true,
		Branch: plumbing.NewBranchReferenceName(bn),
	})
	if err != nil {
		return fmt.Sprintf("Failed to create & switch to branch '%s': %v", bn, err)
	}
	gitContext.Branch = bn
	return fmt.Sprintf("Created & switched to new branch '%s'.", bn)
}

func llmGitStatus() string {
	if !gitContext.Enabled {
		return "Git not initialized."
	}
	repo, err := git.PlainOpen(baseDir)
	if err != nil {
		return fmt.Sprintf("Error opening Git repository: %v", err)
	}
	headRef, err := repo.Head()
	branchName := "detached HEAD"
	if err == nil {
		branchName = headRef.Name().Short()
	}

	hasChanges, files := getGitStatusPorcelain()
	if !hasChanges {
		return fmt.Sprintf("On branch '%s'. Working tree clean.", branchName)
	}

	lines := []string{fmt.Sprintf("On branch '%s'.", branchName)}
	staged := []string{}
	unstaged := []string{}
	untracked := []string{}

	for _, line := range files {
		if len(line) < 3 {
			continue
		}
		code := line[:2]
		filename := line[3:]

		if code == "??" {
			untracked = append(untracked, filename)
		} else if strings.HasPrefix(code, " ") {
			unstaged = append(unstaged, fmt.Sprintf("%s %s", strings.TrimSpace(code), filename))
		} else {
			staged = append(staged, fmt.Sprintf("%s %s", strings.TrimSpace(code), filename))
		}
	}

	if len(staged) > 0 {
		lines = append(lines, "\nChanges to be committed:")
		for _, s := range staged {
			lines = append(lines, fmt.Sprintf("  %s", s))
		}
	}
	if len(unstaged) > 0 {
		lines = append(lines, "\nChanges not staged for commit:")
		for _, s := range unstaged {
			lines = append(lines, fmt.Sprintf("  %s", s))
		}
	}
	if len(untracked) > 0 {
		lines = append(lines, "\nUntracked files:")
		for _, f := range untracked {
			lines = append(lines, fmt.Sprintf("  %s", f))
		}
	}
	return strings.Join(lines, "\n")
}

func llmRunPowershell(command string) string {
	// SECURITY GATE
	if securityContext.RequirePowershellConfirmation {
		color.Red("🚨 Security Confirmation Required")
		color.Yellow("The assistant wants to run this PowerShell command:\n\n%s", command)
		prompt := promptui.Prompt{
			Label: color.BlueString("🔵 Do you want to allow this command to run? (y/N)"),
			IsConfirm: true,
		}
		result, err := prompt.Run()
		if err != nil || strings.ToLower(result) != "y" {
			color.Red("Execution denied by user.")
			return "PowerShell command execution was denied by the user."
		}
	}

	cmd := exec.Command("powershell", "-Command", command)
	output, err := cmd.CombinedOutput()
	if err != nil {
		return fmt.Sprintf("PowerShell Error:\\n%s\\n%v", string(output), err)
	}
	return fmt.Sprintf("PowerShell Output:\\n%s", string(output))
}

// New LLM Tool Handlers (Placeholders)
func llmCodeFinder(filePath, pattern string, isRegex bool) string {
	content, err := readLocalFile(filePath)
	if err != nil {
		return fmt.Sprintf("Error reading file '%s': %v", filePath, err)
	}

	var matches []string
	lines := strings.Split(content, "\n")

	if isRegex {
		re, err := regexp.Compile(pattern)
		if err != nil {
			return fmt.Sprintf("Invalid regex pattern: %v", err)
		}
		for i, line := range lines {
			if re.MatchString(line) {
				matches = append(matches, fmt.Sprintf("Line %d: %s", i+1, line))
			}
		}
	} else {
		for i, line := range lines {
			if strings.Contains(line, pattern) {
				matches = append(matches, fmt.Sprintf("Line %d: %s", i+1, line))
			}
		}
	}

	if len(matches) == 0 {
		return fmt.Sprintf("No matches found for pattern '%s' in file '%s'.", pattern, filePath)
	}
	return fmt.Sprintf("Found %d matches in '%s':\n%s", len(matches), filePath, strings.Join(matches, "\n"))
}

func llmStringReplacer(filePath, oldString, newString string, isRegex, allMatches bool) string {
	content, err := readLocalFile(filePath)
	if err != nil {
		return fmt.Sprintf("Error reading file '%s': %v", filePath, err)
	}

	var updatedContent string
	if isRegex {
		re, err := regexp.Compile(oldString)
		if err != nil {
			return fmt.Sprintf("Invalid regex pattern: %v", err)
		}
		if allMatches {
			updatedContent = re.ReplaceAllString(content, newString)
		} else {
			// Find the first match and replace it
			matchIndex := re.FindStringIndex(content)
			if matchIndex == nil {
				updatedContent = content // No match, no change
			} else {
				updatedContent = content[:matchIndex[0]] + newString + content[matchIndex[1]:]
			}
		}
	} else {
		if allMatches {
			updatedContent = strings.ReplaceAll(content, oldString, newString)
		} else {
			updatedContent = strings.Replace(content, oldString, newString, 1)
		}
	}

	if updatedContent == content {
		return fmt.Sprintf("No changes made to file '%s'. Pattern not found or no replacements needed.", filePath)
	}

	err = createFile(filePath, updatedContent)
	if err != nil {
		return fmt.Sprintf("Error writing updated file '%s': %v", filePath, err)
	}
	return fmt.Sprintf("Successfully replaced content in file '%s'.", filePath)
}

func llmGrepPlusPlus(directory, pattern, fileFilter string, recursive bool) string {
	matches := []string{}
	searchDir := normalizePath(directory)

	re, err := regexp.Compile(pattern)
	if err != nil {
		return fmt.Sprintf("Invalid regex pattern: %v", err)
	}

	filepath.Walk(searchDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return nil // Continue walking on error
		}
		if info.IsDir() {
			if !recursive && path != searchDir {
				return filepath.SkipDir // Skip subdirectories if not recursive
			}
			// Skip excluded directories
			for dir := range excludedFiles {
				if info.Name() == dir || strings.HasPrefix(info.Name(), ".") {
					return filepath.SkipDir
				}
			}
			return nil
		}

		// Apply file filter
		if fileFilter != "" {
			matched, err := filepath.Match(fileFilter, info.Name())
			if err != nil || !matched {
				return nil
			}
		}

		// Skip excluded files and binary files
		if excludedFiles[info.Name()] || excludedExtensions[filepath.Ext(info.Name())] || isBinaryFile(path, 1024) {
			return nil
		}

		content, err := readLocalFile(path)
		if err != nil {
			return nil // Skip if cannot read
		}

		lines := strings.Split(content, "\n")
		for i, line := range lines {
			if re.MatchString(line) {
				// Add context: 2 lines before, the matching line, 2 lines after
				contextLines := []string{}
				start := i - 2
				if start < 0 {
					start = 0
				}
				end := i + 3
				if end > len(lines) {
					end = len(lines)
				}

				for j := start; j < end; j++ {
					prefix := "  "
					if j == i {
						prefix = "> " // Mark the matching line
					}
					contextLines = append(contextLines, fmt.Sprintf("%s%s", prefix, lines[j]))
				}
				matches = append(matches, fmt.Sprintf("File: %s (Lines %d-%d):\n%s\n", path, start+1, end, strings.Join(contextLines, "\n")))
			}
		}
		return nil
	})

	if len(matches) == 0 {
		return fmt.Sprintf("No matches found for pattern '%s' in directory '%s'.", pattern, directory)
	}
	return fmt.Sprintf("Found %d matches:\n\n%s", len(matches), strings.Join(matches, "\n---\n"))
}

func llmLongFileIndexer(filePath string, chunkSize int) string {
	content, err := readLocalFile(filePath)
	if err != nil {
		return fmt.Sprintf("Error reading file '%s': %v", filePath, err)
	}

	lines := strings.Split(content, "\n")
	numLines := len(lines)
	
	if chunkSize <= 0 {
		return fmt.Sprintf("Error: chunkSize must be a positive integer. Provided: %d", chunkSize)
	}

	numChunks := (numLines + chunkSize - 1) / chunkSize
	indexInfo := []string{fmt.Sprintf("Indexed file '%s' into %d chunks:", filePath, numChunks)}

	for i := 0; i < numChunks; i++ {
		startLine := i * chunkSize
		endLine := (i + 1) * chunkSize
		if endLine > numLines {
			endLine = numLines
		}
		
		chunkContent := strings.Join(lines[startLine:endLine], "\n")
		// In a real scenario, you'd store this chunk content or a hash/summary of it
		// and provide a way to retrieve specific chunks. For this agent, we'll just summarize.
		
		// Create a small summary of the chunk content (e.g., first 50 chars + last 50 chars)
		summary := chunkContent
		if len(chunkContent) > 100 {
			summary = chunkContent[:50] + "..." + chunkContent[len(chunkContent)-50:]
		}
		
		indexInfo = append(indexInfo, fmt.Sprintf("  Chunk %d: Lines %d-%d (approx %d chars). Summary: \"%s\"", 
			i+1, startLine+1, endLine, len(chunkContent), summary))
	}
	return strings.Join(indexInfo, "\n")
}

func llmInputFixer(malformedCode, language string) string {
	// In a real scenario, this would involve sending the malformedCode to an LLM
	// with instructions to fix it based on the specified language.
	// For example, using deepseekClient.CreateChatCompletion with a specific prompt.
	// Since direct LLM calls are outside the scope of tool execution in this simplified model,
	// we'll return a message indicating this and the original code.
	
	// Example of what a real implementation might look like (conceptual):
	/*
	   prompt := fmt.Sprintf("Fix the following malformed %s code. Provide only the corrected code:\n\n%s", language, malformedCode)
	   // Make an LLM call here, e.g., to deepseekClient
	   // response, err := deepseekClient.CreateChatCompletion(context.Background(), openai.ChatCompletionRequest{
	   //    Model: defaultModel,
	   //    Messages: []openai.ChatCompletionMessage{{Role: "user", Content: prompt}},
	   // })
	   // if err != nil {
	   //    return fmt.Sprintf("Error fixing code with LLM: %v\nOriginal Code:\n%s", err, malformedCode)
	   // }
	   // return response.Choices[0].Message.Content
	*/

	return fmt.Sprintf("Auto-fixer (LLM integration not active in this build) attempted to fix malformed %s code.\nOriginal:\n%s\n\nReturning original code.", language, malformedCode)
}

type Task struct {
	Description string
	Completed   bool
}

var taskBucket = []Task{}
var taskBucketMutex sync.Mutex

func llmAutoTaskPlanner(mainTaskDescription string, subTasks []string) string {
	taskBucketMutex.Lock()
	defer taskBucketMutex.Unlock()

	// Clear existing tasks to avoid accumulation from previous calls
	taskBucket = []Task{}

	taskBucket = append(taskBucket, Task{Description: mainTaskDescription, Completed: false})
	for _, sub := range subTasks {
		taskBucket = append(taskBucket, Task{Description: "  - " + sub, Completed: false})
	}
	return fmt.Sprintf("Main task '%s' and %d sub-tasks added to the task bucket.", mainTaskDescription, len(subTasks))
}

func tryHandleTaskCommand(userInput string) bool {
	if strings.ToLower(strings.TrimSpace(userInput)) == "/task" {
		taskBucketMutex.Lock()
		defer taskBucketMutex.Unlock()

		if len(taskBucket) == 0 {
			color.Yellow("Task bucket is empty. No pending tasks.")
			return true
		}

		fmt.Println(color.BlueString("📋 Current Task List:"))
		for i, task := range taskBucket {
			status := " "
			if task.Completed {
				status = "✓"
			}
			fmt.Printf("%d. [%s] %s\n", i+1, status, task.Description)
		}
		color.Cyan("\nUse /task set <number> completed to mark a task as completed.")
		return true
	} else if strings.HasPrefix(strings.ToLower(userInput), "/task set ") {
		parts := strings.Fields(userInput)
		if len(parts) >= 4 && parts[2] == "completed" {
			taskNumStr := parts[1]
			taskNum, err := strconv.Atoi(taskNumStr)
			if err != nil || taskNum <= 0 || taskNum > len(taskBucket) {
				color.Red("Invalid task number. Use /task to see task numbers.")
				return true
			}

			taskBucketMutex.Lock()
			defer taskBucketMutex.Unlock()

			taskBucket[taskNum-1].Completed = true
			color.Green("✓ Task %d marked as completed.", taskNum)
		} else {
			color.Yellow("Usage: /task set <number> completed")
		}
		return true
	}
	return false
}

func executeFunctionCall(toolCall map[string]interface{}) string {
	funcName, _ := toolCall["function"].(map[string]interface{})["name"].(string)
	argsJSON, _ := toolCall["function"].(map[string]interface{})["arguments"].(string)

	var args map[string]interface{}
	if err := json.Unmarshal([]byte(argsJSON), &args); err != nil {
		return fmt.Sprintf("Error: Invalid JSON arguments for %s: %v", funcName, err)
	}

	switch funcName {
	case "read_file":
		filePath, _ := args["file_path"].(string)
		content, err := readLocalFile(filePath)
		if err != nil {
			return fmt.Sprintf("Error reading file '%s': %v", filePath, err)
		}
		return fmt.Sprintf("Content of file '%s':\n\n%s", filePath, content)
	case "read_multiple_files":
		filePaths, _ := args["file_paths"].([]interface{})
		var paths []string
		for _, p := range filePaths {
			paths = append(paths, p.(string))
		}
		response := map[string]interface{}{
			"files_read": map[string]string{},
			"errors":     map[string]string{},
		}
		totalContentSize := 0
		for _, fp := range paths {
			normalizedPath := normalizePath(fp)
			content, err := readLocalFile(normalizedPath)
			if err != nil {
				response["errors"].(map[string]string)[normalizedPath] = err.Error()
				continue
			}
			if totalContentSize+len(content) > maxMultipleReadSize {
				response["errors"].(map[string]string)[normalizedPath] = "Could not read file, as total content size would exceed the safety limit."
				continue
			}
			response["files_read"].(map[string]string)[normalizedPath] = content
			totalContentSize += len(content)
		}
		jsonResponse, _ := json.MarshalIndent(response, "", "  ")
		return string(jsonResponse)
	case "create_file":
		filePath, _ := args["file_path"].(string)
		content, _ := args["content"].(string)
		err := createFile(filePath, content)
		if err != nil {
			return fmt.Sprintf("Error creating file '%s': %v", filePath, err)
		}
		return fmt.Sprintf("File '%s' created/updated.", filePath)
	case "create_multiple_files":
		filesData, _ := args["files"].([]interface{})
		var files []FileToCreate
		for _, f := range filesData {
			fMap := f.(map[string]interface{})
			files = append(files, FileToCreate{
				Path:    fMap["path"].(string),
				Content: fMap["content"].(string),
			})
		}
		result, err := createMultipleFiles(files)
		if err != nil {
			return fmt.Sprintf("Error creating multiple files: %v", err)
		}
		return result
	case "edit_file":
		filePath, _ := args["file_path"].(string)
		originalSnippet, _ := args["original_snippet"].(string)
		newSnippet, _ := args["new_snippet"].(string)
		err := applyFuzzyDiffEdit(filePath, originalSnippet, newSnippet)
		if err != nil {
			return fmt.Sprintf("Error during edit_file call for '%s': %v", filePath, err)
		}
		return fmt.Sprintf("Edit applied successfully to '%s'.", filePath)
	case "git_init":
		return llmGitInit()
	case "git_add":
		filePaths, _ := args["file_paths"].([]interface{})
		var paths []string
		for _, p := range filePaths {
			paths = append(paths, p.(string))
		}
		return llmGitAdd(paths)
	case "git_commit":
		message, _ := args["message"].(string)
		return llmGitCommit(message)
	case "git_create_branch":
		branchName, _ := args["branch_name"].(string)
		return llmGitCreateBranch(branchName)
	case "git_status":
		return llmGitStatus()
	case "run_powershell":
		command, _ := args["command"].(string)
		output := llmRunPowershell(command) // llmRunPowershell directly returns formatted string
		return output
	case "code_finder":
		filePath, _ := args["file_path"].(string)
		pattern, _ := args["pattern"].(string)
		isRegex, _ := args["is_regex"].(bool)
		return llmCodeFinder(filePath, pattern, isRegex)
	case "string_replacer":
		filePath, _ := args["file_path"].(string)
		oldString, _ := args["old_string"].(string)
		newString, _ := args["new_string"].(string)
		isRegex, _ := args["is_regex"].(bool)
		allMatches, _ := args["all_matches"].(bool)
		return llmStringReplacer(filePath, oldString, newString, isRegex, allMatches)
	case "grep_plus_plus":
		directory, _ := args["directory"].(string)
		pattern, _ := args["pattern"].(string)
		fileFilter, _ := args["file_filter"].(string)
		recursive, _ := args["recursive"].(bool)
		return llmGrepPlusPlus(directory, pattern, fileFilter, recursive)
	case "long_file_indexer":
		filePath, _ := args["file_path"].(string)
		chunkSize, _ := args["chunk_size"].(float64) // JSON numbers are float64
		return llmLongFileIndexer(filePath, int(chunkSize))
	case "input_fixer":
		malformedCode, _ := args["malformed_code"].(string)
		language, _ := args["language"].(string)
				lines = append(lines, fmt.Sprintf("%s%s/", prefix, entry.Name()))
				entryCount++
				walk(filepath.Join(dirPath, entry.Name()), prefix+"  ", depth+1)
			} else {
				lines = append(lines, fmt.Sprintf("%s%s", prefix, entry.Name()))
				entryCount++
			}
		}
	}

	walk(rootPath, "", 0)

	return strings.Join(lines, "\n")
}
func main() {
	color.Blue("🚀 DeepSeek Engineer Assistant - Enhanced Edition (Go)")
	color.Cyan("✨ Now with fuzzy matching for files and code edits!")
	color.Cyan("Type /help for commands. Ctrl+C to interrupt, Ctrl+D or /exit to quit.")

	// Show fuzzy matching status on startup
	color.Green("✓ Fuzzy matching implemented and enabled in Go.")

	// Add directory structure as a system message before starting the main loop
	dirSummary := getDirectoryTreeSummary(baseDir, 3, 100)
	conversationHistory = append(conversationHistory, map[string]interface{}{
		"role":    "system",
		"content": fmt.Sprintf("Project directory structure at startup:\n\n%s", dirSummary),
	})

	initializeApplication()
	mainLoop()
}
